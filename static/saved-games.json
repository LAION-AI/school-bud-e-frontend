{
  "games": [
    {
      "id": "343b3e02-d9f7-43e0-80db-abd6c517e295",
      "name": "Binary Multiplication Game",
      "code": "const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#f1f8e9', scene: { preload, create, update } }; const game = new Phaser.Game(config); let currentAnswers = []; let correctAnswer; let score = 0; let mistakes = []; function preload() { } function create() { this.titleText = this.add.text(400, 50, 'Binary Multiplication Game', { font: '28px Arial', fill: '#33691e' }).setOrigin(0.5); this.resultText = this.add.text(400, 500, '', { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); generateBinaryQuestion(this); this.input.keyboard.on('keydown', handleKeyPress, this); } function update() { } function generateBinaryQuestion(scene) { const a = Phaser.Math.Between(1, 15).toString(2); const b = Phaser.Math.Between(1, 15).toString(2); correctAnswer = parseInt(a, 2) * parseInt(b, 2); scene.questionText = scene.add.text(400, 150, `What is ${a} * ${b} in binary?`, { font: '24px Arial', fill: '#558b2f' }).setOrigin(0.5); if (scene.answerTexts) { scene.answerTexts.forEach(text => text.destroy()); } currentAnswers = [correctAnswer.toString(2), (correctAnswer + 1).toString(2), (correctAnswer - 1).toString(2)]; Phaser.Utils.Array.Shuffle(currentAnswers); scene.answerTexts = currentAnswers.map((answer, index) => { return scene.add.text(400, 200 + index * 50, `${index + 1}: ${answer}`, { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); }); } function handleKeyPress(event) { const keyIndex = parseInt(event.key) - 1; if (keyIndex >= 0 && keyIndex < currentAnswers.length) { const selectedAnswer = parseInt(currentAnswers[keyIndex], 2); if (selectedAnswer === correctAnswer) { this.resultText.setText('Correct!'); score += 10; gameScore('Binary Multiplication Game', score); } else { this.resultText.setText('Incorrect, try again!'); mistakes.push(`Mistake: ${currentAnswers[keyIndex]} for ${correctAnswer.toString(2)} (${currentAnswers.join(', ')})`); console.log(mistakes); } setTimeout(() => { resetQuestion(this); }, 500); } } function resetQuestion(scene) { scene.questionText.destroy(); scene.answerTexts.forEach(text => text.destroy()); scene.resultText.setText(''); generateBinaryQuestion(scene); }",
      "timestamp": "2025-02-03T17:54:58.011Z",
      "totalPoints": 0
    },
    {
      "id": "6d1823b3-5b7a-4099-a46d-c5415d5c86eb",
      "name": "Multiplication Game",
      "code": "const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#f1f8e9', scene: { preload, create, update } }; const game = new Phaser.Game(config); let currentAnswers = []; let correctAnswer; let score = 0; let mistakes = []; function preload() { } function create() { this.titleText = this.add.text(400, 50, 'Binary Multiplication Game', { font: '28px Arial', fill: '#33691e' }).setOrigin(0.5); this.resultText = this.add.text(400, 500, '', { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); generateBinaryQuestion(this); this.input.keyboard.on('keydown', handleKeyPress, this); } function update() { } function generateBinaryQuestion(scene) { const a = Phaser.Math.Between(1, 15).toString(2); const b = Phaser.Math.Between(1, 15).toString(2); correctAnswer = parseInt(a, 2) * parseInt(b, 2); scene.questionText = scene.add.text(400, 150, `What is ${a} * ${b} in binary?`, { font: '24px Arial', fill: '#558b2f' }).setOrigin(0.5); if (scene.answerTexts) { scene.answerTexts.forEach(text => text.destroy()); } currentAnswers = [correctAnswer.toString(2), (correctAnswer + 1).toString(2), (correctAnswer - 1).toString(2)]; Phaser.Utils.Array.Shuffle(currentAnswers); scene.answerTexts = currentAnswers.map((answer, index) => { return scene.add.text(400, 200 + index * 50, `${index + 1}: ${answer}`, { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); }); } function handleKeyPress(event) { const keyIndex = parseInt(event.key) - 1; if (keyIndex >= 0 && keyIndex < currentAnswers.length) { const selectedAnswer = parseInt(currentAnswers[keyIndex], 2); if (selectedAnswer === correctAnswer) { this.resultText.setText('Correct!'); score += 10; gameScore('Binary Multiplication Game', score); } else { this.resultText.setText('Incorrect, try again!'); mistakes.push(`Mistake: ${currentAnswers[keyIndex]} for ${correctAnswer.toString(2)} (${currentAnswers.join(', ')})`); console.log(mistakes); } setTimeout(() => { resetQuestion(this); }, 500); } } function resetQuestion(scene) { scene.questionText.destroy(); scene.answerTexts.forEach(text => text.destroy()); scene.resultText.setText(''); generateBinaryQuestion(scene); }",
      "timestamp": "2025-02-03T18:15:22.718Z",
      "totalPoints": 0
    },
    {
      "id": "ccf899f4-c55a-4ab0-b935-aef7301416e6",
      "name": "Binary Multiplication Game Edit",
      "code": "const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#f1f8e9', scene: { preload, create, update }, parent: 'phaser-game' }; const game = new Phaser.Game(config); let currentAnswers = []; let correctAnswer; let score = 0; let mistakes = []; function preload() { } function create() { this.titleText = this.add.text(400, 50, 'Binary Multiplication Game', { font: '28px Arial', fill: '#33691e' }).setOrigin(0.5); this.resultText = this.add.text(400, 500, '', { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); generateBinaryQuestion(this); this.input.keyboard.on('keydown', handleKeyPress, this); } function update() { } function generateBinaryQuestion(scene) { const a = Phaser.Math.Between(1, 15).toString(2); const b = Phaser.Math.Between(1, 15).toString(2); correctAnswer = parseInt(a, 2) * parseInt(b, 2); scene.questionText = scene.add.text(400, 150, `What is ${a} * ${b} in binary?`, { font: '24px Arial', fill: '#558b2f' }).setOrigin(0.5); if (scene.answerTexts) { scene.answerTexts.forEach(text => text.destroy()); } currentAnswers = [correctAnswer.toString(2), (correctAnswer + 1).toString(2), (correctAnswer - 1).toString(2)]; Phaser.Utils.Array.Shuffle(currentAnswers); scene.answerTexts = currentAnswers.map((answer, index) => { return scene.add.text(400, 200 + index * 50, `${index + 1}: ${answer}`, { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); }); } function handleKeyPress(event) { const keyIndex = parseInt(event.key) - 1; if (keyIndex >= 0 && keyIndex < currentAnswers.length) { const selectedAnswer = parseInt(currentAnswers[keyIndex], 2); if (selectedAnswer === correctAnswer) { this.resultText.setText('Correct!'); score += 10; gameScore('Binary Multiplication Game', score); } else { this.resultText.setText('Incorrect, try again!'); mistakes.push(`Mistake: ${currentAnswers[keyIndex]} for ${correctAnswer.toString(2)} (${currentAnswers.join(', ')})`); console.log(mistakes); } setTimeout(() => { resetQuestion(this); }, 500); } } function resetQuestion(scene) { scene.questionText.destroy(); scene.answerTexts.forEach(text => text.destroy()); scene.resultText.setText(''); generateBinaryQuestion(scene); }",
      "timestamp": "2025-02-04T11:28:21.901Z",
      "totalPoints": 0
    },
    {
      "id": "e6273dcd-7a7f-44e3-af00-bd2f11c4a9e4",
      "name": "Multiplication Game",
      "code": "const config = { type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#f1f8e9', scene: { preload, create, update }, parent: 'phaser-game' }; const game = new Phaser.Game(config); let currentAnswers = []; let correctAnswer; let score = 0; let mistakes = []; function preload() { } function create() { this.titleText = this.add.text(400, 50, 'Binary Multiplication Game', { font: '28px Arial', fill: '#33691e' }).setOrigin(0.5); this.resultText = this.add.text(400, 500, '', { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); generateBinaryQuestion(this); this.input.keyboard.on('keydown', handleKeyPress, this); } function update() { } function generateBinaryQuestion(scene) { const a = Phaser.Math.Between(1, 15).toString(2); const b = Phaser.Math.Between(1, 15).toString(2); correctAnswer = parseInt(a, 2) * parseInt(b, 2); scene.questionText = scene.add.text(400, 150, `What is ${a} * ${b} in binary?`, { font: '24px Arial', fill: '#558b2f' }).setOrigin(0.5); if (scene.answerTexts) { scene.answerTexts.forEach(text => text.destroy()); } currentAnswers = [correctAnswer.toString(2), (correctAnswer + 1).toString(2), (correctAnswer - 1).toString(2)]; Phaser.Utils.Array.Shuffle(currentAnswers); scene.answerTexts = currentAnswers.map((answer, index) => { return scene.add.text(400, 200 + index * 50, `${index + 1}: ${answer}`, { font: '24px Arial', fill: '#33691e' }).setOrigin(0.5); }); } function handleKeyPress(event) { const keyIndex = parseInt(event.key) - 1; if (keyIndex >= 0 && keyIndex < currentAnswers.length) { const selectedAnswer = parseInt(currentAnswers[keyIndex], 2); if (selectedAnswer === correctAnswer) { this.resultText.setText('Correct!'); score += 10; gameScore('Binary Multiplication Game', score); } else { this.resultText.setText('Incorrect, try again!'); mistakes.push(`Mistake: ${currentAnswers[keyIndex]} for ${correctAnswer.toString(2)} (${currentAnswers.join(', ')})`); console.log(mistakes); } setTimeout(() => { resetQuestion(this); }, 500); } } function resetQuestion(scene) { scene.questionText.destroy(); scene.answerTexts.forEach(text => text.destroy()); scene.resultText.setText(''); generateBinaryQuestion(scene); }",
      "timestamp": "2025-02-04T11:36:31.471Z",
      "totalPoints": 0
    },
    {
      "id": "6095d87c-40d0-4abe-b39b-bcdab1553f4d",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#b3e5fc',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for binary question UI and score\nlet currentAnswers = [];\nlet correctAnswer = 0;\nlet questionActive = false;\nlet questionText;\nlet answerTexts = [];\nlet score = 0;\nlet scoreText;\nlet mistakes = [];\n\nfunction preload() {\n  // Create a graphics object for drawing textures\n  this.graphics = this.add.graphics();\n\n  // Create a simple player texture (blue rectangle)\n  this.graphics.fillStyle(0x0000ff, 1);\n  this.graphics.fillRect(0, 0, 32, 48);\n  this.graphics.generateTexture('player', 32, 48);\n  this.graphics.clear();\n\n  // Create a simple enemy texture (red rectangle)\n  this.graphics.fillStyle(0xff0000, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('enemy', 32, 32);\n  this.graphics.clear();\n\n  // Create a platform texture (green rectangle)\n  this.graphics.fillStyle(0x00ff00, 1);\n  this.graphics.fillRect(0, 0, 400, 32);\n  this.graphics.generateTexture('platform', 400, 32);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // Create platforms using a static physics group\n  this.platforms = this.physics.add.staticGroup();\n  // Ground platform (stretched to cover the bottom)\n  this.platforms.create(400, 584, 'platform').setScale(2).refreshBody();\n  // Additional platforms\n  this.platforms.create(600, 400, 'platform');\n  this.platforms.create(50, 250, 'platform');\n  this.platforms.create(750, 220, 'platform');\n\n  // Create the player sprite and enable physics\n  this.player = this.physics.add.sprite(100, 450, 'player');\n  this.player.setBounce(0.2);\n  this.player.setCollideWorldBounds(true);\n\n  // Create the enemy sprite\n  this.enemy = this.physics.add.sprite(700, 450, 'enemy');\n  this.enemy.setBounce(1);\n  this.enemy.setCollideWorldBounds(true);\n  this.enemy.setVelocityX(-100);\n\n  // Enable collisions between the player/enemy and the platforms\n  this.physics.add.collider(this.player, this.platforms);\n  this.physics.add.collider(this.enemy, this.platforms);\n\n  // When the enemy overlaps the player, trigger the question routine\n  this.physics.add.overlap(this.player, this.enemy, onEnemyHit, null, this);\n\n  // Set up keyboard controls for player movement\n  this.cursors = this.input.keyboard.createCursorKeys();\n\n  // Create score text\n  scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '20px', fill: '#000' });\n\n  // Create a text object for showing the result (positioned later)\n  // (We will reuse this text for question results.)\n  this.resultText = this.add.text(400, 350, '', { font: '24px Arial', fill: '#000' }).setOrigin(0.5);\n\n  // Listen for keyboard events (for answering binary questions)\n  this.input.keyboard.on('keydown', handleKeyPress, this);\n}\n\nfunction update() {\n  if (!questionActive) {\n    // --- Player movement logic ---\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-330);\n    }\n\n    // --- Enemy patrol logic ---\n    // Reverse enemy direction if it touches the left or right bounds of its body\n    if (this.enemy.body.blocked.left) {\n      this.enemy.setVelocityX(100);\n    } else if (this.enemy.body.blocked.right) {\n      this.enemy.setVelocityX(-100);\n    }\n  }\n}\n\n// This function is called when the enemy hits the player.\nfunction onEnemyHit(player, enemy) {\n  if (!questionActive) {\n    questionActive = true;\n    // Pause the physics to \"freeze\" the game during the question\n    this.physics.pause();\n    // Show the binary multiplication question UI\n    generateBinaryQuestion(this);\n  }\n}\n\n// This function generates and displays a binary multiplication question.\nfunction generateBinaryQuestion(scene) {\n  // Generate two random numbers (1 to 15) and convert them to binary strings.\n  const a = Phaser.Math.Between(1, 15);\n  const b = Phaser.Math.Between(1, 15);\n  const aBinary = a.toString(2);\n  const bBinary = b.toString(2);\n  correctAnswer = a * b;\n\n  // Display the question in the center of the screen.\n  questionText = scene.add.text(\n    400,\n    200,\n    `What is ${aBinary} * ${bBinary} in binary?`,\n    { font: '24px Arial', fill: '#000' }\n  ).setOrigin(0.5);\n\n  // Create three answer options: the correct answer, one more, and one less.\n  currentAnswers = [\n    correctAnswer.toString(2),\n    (correctAnswer + 1).toString(2),\n    (correctAnswer - 1).toString(2)\n  ];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n\n  // Display the answer options.\n  answerTexts = [];\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let optionText = scene.add.text(\n      400,\n      250 + i * 40,\n      `${i + 1}: ${currentAnswers[i]}`,\n      { font: '24px Arial', fill: '#000' }\n    ).setOrigin(0.5);\n    answerTexts.push(optionText);\n  }\n}\n\n// This function handles key presses for answering the question.\nfunction handleKeyPress(event) {\n  // Only process input if a question is active.\n  if (!questionActive) {\n    return;\n  }\n  // Check if the pressed key is '1', '2', or '3'.\n  const keyIndex = parseInt(event.key) - 1;\n  if (keyIndex >= 0 && keyIndex < currentAnswers.length) {\n    // Convert the chosen binary answer to an integer.\n    const selectedAnswer = parseInt(currentAnswers[keyIndex], 2);\n    if (selectedAnswer === correctAnswer) {\n      // Correct answer\n      this.resultText.setText('Correct!');\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    } else {\n      // Incorrect answer\n      this.resultText.setText('Incorrect, try again!');\n      mistakes.push(`Mistake: Selected ${currentAnswers[keyIndex]} instead of ${correctAnswer.toString(2)}`);\n      console.log(mistakes);\n      // Reset the question after a short delay to allow another try.\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    }\n  }\n}\n\n// This function removes the question UI and resumes the game.\nfunction resetQuestion(scene) {\n  if (questionText) {\n    questionText.destroy();\n  }\n  answerTexts.forEach(text => text.destroy());\n  this.resultText.setText('');\n  questionActive = false;\n  // Resume physics so the game continues.\n  scene.physics.resume();\n}\n",
      "timestamp": "2025-02-04T12:20:39.099Z",
      "totalPoints": 0
    },
    {
      "id": "14d0fd85-2926-47d6-b412-5e25dd02a951",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#b3e5fc',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for binary question UI, score, and level\nlet currentAnswers = [];\nlet correctAnswer = 0;\nlet questionActive = false;\nlet questionText;\nlet answerTexts = [];\nlet score = 0;\nlet scoreText;\nlet mistakes = [];\nlet level = 1;\nlet levelText;\n\nfunction preload() {\n  // Create a graphics object for drawing textures\n  this.graphics = this.add.graphics();\n\n  // Create a simple player texture (blue rectangle)\n  this.graphics.fillStyle(0x0000ff, 1);\n  this.graphics.fillRect(0, 0, 32, 48);\n  this.graphics.generateTexture('player', 32, 48);\n  this.graphics.clear();\n\n  // Create a simple enemy texture (red rectangle)\n  this.graphics.fillStyle(0xff0000, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('enemy', 32, 32);\n  this.graphics.clear();\n\n  // Create a platform texture (green rectangle)\n  this.graphics.fillStyle(0x00ff00, 1);\n  this.graphics.fillRect(0, 0, 400, 32);\n  this.graphics.generateTexture('platform', 400, 32);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // Create platforms using a static physics group\n  this.platforms = this.physics.add.staticGroup();\n  // Ground platform (stretched to cover the bottom)\n  this.platforms.create(400, 584, 'platform').setScale(2).refreshBody();\n  // Additional platforms\n  this.platforms.create(600, 400, 'platform');\n  this.platforms.create(50, 250, 'platform');\n  this.platforms.create(750, 220, 'platform');\n\n  // Create the player sprite and enable physics\n  this.player = this.physics.add.sprite(100, 450, 'player');\n  this.player.setBounce(0.2);\n  this.player.setCollideWorldBounds(true);\n\n  // Create enemies group and add multiple enemies\n  this.enemies = this.physics.add.group();\n  // Enemy 1\n  let enemy1 = this.enemies.create(700, 450, 'enemy');\n  enemy1.setBounce(1);\n  enemy1.setCollideWorldBounds(true);\n  enemy1.setVelocityX(-100);\n  // Enemy 2\n  let enemy2 = this.enemies.create(400, 300, 'enemy');\n  enemy2.setBounce(1);\n  enemy2.setCollideWorldBounds(true);\n  enemy2.setVelocityX(80);\n  // Enemy 3\n  let enemy3 = this.enemies.create(600, 150, 'enemy');\n  enemy3.setBounce(1);\n  enemy3.setCollideWorldBounds(true);\n  enemy3.setVelocityX(-120);\n\n  // Enable collisions between the player/enemies and the platforms\n  this.physics.add.collider(this.player, this.platforms);\n  this.physics.add.collider(this.enemies, this.platforms);\n\n  // When an enemy overlaps the player, trigger the question routine\n  this.physics.add.overlap(this.player, this.enemies, onEnemyHit, null, this);\n\n  // Set up keyboard controls for player movement\n  this.cursors = this.input.keyboard.createCursorKeys();\n\n  // Create score text\n  scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '20px', fill: '#000' });\n  \n  // Create level text\n  levelText = this.add.text(16, 40, 'Level: 1', { fontSize: '20px', fill: '#000' });\n\n  // Create a text object for showing the result (used for question feedback)\n  this.resultText = this.add.text(400, 350, '', { font: '24px Arial', fill: '#000' }).setOrigin(0.5);\n\n  // Listen for keyboard events (for answering binary questions)\n  this.input.keyboard.on('keydown', handleKeyPress, this);\n}\n\nfunction update() {\n  if (!questionActive) {\n    // --- Player movement logic ---\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-330);\n    }\n\n    // --- Enemy patrol logic ---\n    this.enemies.getChildren().forEach(enemy => {\n      if (enemy.body.blocked.left) {\n        enemy.setVelocityX(Math.abs(enemy.body.velocity.x));\n      } else if (enemy.body.blocked.right) {\n        enemy.setVelocityX(-Math.abs(enemy.body.velocity.x));\n      }\n    });\n\n    // --- Level progression logic ---\n    // If the player reaches near the top of the screen, advance to the next level.\n    if (this.player.y < 50) {\n      nextLevel(this);\n    }\n  }\n}\n\n// This function is called when an enemy hits the player.\nfunction onEnemyHit(player, enemy) {\n  if (!questionActive) {\n    questionActive = true;\n    // Pause the physics to \"freeze\" the game during the question\n    this.physics.pause();\n    // Show the binary multiplication question UI\n    generateBinaryQuestion(this);\n  }\n}\n\n// This function generates and displays a binary multiplication question.\nfunction generateBinaryQuestion(scene) {\n  // Generate two random numbers (1 to 15) and convert them to binary strings.\n  const a = Phaser.Math.Between(1, 15);\n  const b = Phaser.Math.Between(1, 15);\n  const aBinary = a.toString(2);\n  const bBinary = b.toString(2);\n  correctAnswer = a * b;\n\n  // Display the question in the center of the screen.\n  questionText = scene.add.text(\n    400,\n    200,\n    `What is ${aBinary} * ${bBinary} in binary?`,\n    { font: '24px Arial', fill: '#000' }\n  ).setOrigin(0.5);\n\n  // Create three answer options: the correct answer, one more, and one less.\n  currentAnswers = [\n    correctAnswer.toString(2),\n    (correctAnswer + 1).toString(2),\n    (correctAnswer - 1).toString(2)\n  ];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n\n  // Display the answer options.\n  answerTexts = [];\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let optionText = scene.add.text(\n      400,\n      250 + i * 40,\n      `${i + 1}: ${currentAnswers[i]}`,\n      { font: '24px Arial', fill: '#000' }\n    ).setOrigin(0.5);\n    answerTexts.push(optionText);\n  }\n}\n\n// This function handles key presses for answering the question.\nfunction handleKeyPress(event) {\n  // Only process input if a question is active.\n  if (!questionActive) {\n    return;\n  }\n  // Check if the pressed key is '1', '2', or '3'.\n  const keyIndex = parseInt(event.key) - 1;\n  if (keyIndex >= 0 && keyIndex < currentAnswers.length) {\n    // Convert the chosen binary answer to an integer.\n    const selectedAnswer = parseInt(currentAnswers[keyIndex], 2);\n    if (selectedAnswer === correctAnswer) {\n      // Correct answer\n      this.resultText.setText('Correct!');\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    } else {\n      // Incorrect answer\n      this.resultText.setText('Incorrect, try again!');\n      mistakes.push(`Mistake: Selected ${currentAnswers[keyIndex]} instead of ${correctAnswer.toString(2)}`);\n      console.log(mistakes);\n      // Reset the question after a short delay to allow another try.\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    }\n  }\n}\n\n// This function removes the question UI and resumes the game.\nfunction resetQuestion(scene) {\n  if (questionText) {\n    questionText.destroy();\n  }\n  answerTexts.forEach(text => text.destroy());\n  scene.resultText.setText('');\n  questionActive = false;\n  // Resume physics so the game continues.\n  scene.physics.resume();\n}\n\n// This function advances the game to the next level.\nfunction nextLevel(scene) {\n  // Increase the level counter and update the display.\n  level++;\n  levelText.setText('Level: ' + level);\n  \n  // Optionally, add a new enemy to increase the challenge.\n  let newEnemyX = Phaser.Math.Between(50, 750);\n  let newEnemyY = Phaser.Math.Between(50, 300);\n  let newEnemy = scene.enemies.create(newEnemyX, newEnemyY, 'enemy');\n  newEnemy.setBounce(1);\n  newEnemy.setCollideWorldBounds(true);\n  // Set a random horizontal velocity between 100 and 150 (with a random direction).\n  let velocityX = Phaser.Math.Between(100, 150);\n  if (Phaser.Math.Between(0, 1)) {\n    velocityX = -velocityX;\n  }\n  newEnemy.setVelocityX(velocityX);\n\n  // Reset the player's position to the bottom of the screen.\n  scene.player.setPosition(100, 450);\n}\n",
      "timestamp": "2025-02-04T12:24:22.043Z",
      "totalPoints": 0
    },
    {
      "id": "0b67e08d-7504-4058-a34d-d3fcac5cd705",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#b3e5fc',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for binary question UI, score, level, and cooldown\nlet currentAnswers = [];\nlet correctAnswer = 0;\nlet questionActive = false;\nlet questionText;\nlet answerTexts = [];\nlet score = 0;\nlet scoreText;\nlet mistakes = [];\nlet level = 1;\nlet levelText;\nlet hitCooldown = false; // cooldown flag to prevent multiple hits\n\nfunction preload() {\n  // Create a graphics object for drawing textures\n  this.graphics = this.add.graphics();\n\n  // Create a simple player texture (blue rectangle)\n  this.graphics.fillStyle(0x0000ff, 1);\n  this.graphics.fillRect(0, 0, 32, 48);\n  this.graphics.generateTexture('player', 32, 48);\n  this.graphics.clear();\n\n  // Create a simple enemy texture (red rectangle)\n  this.graphics.fillStyle(0xff0000, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('enemy', 32, 32);\n  this.graphics.clear();\n\n  // Create a platform texture (green rectangle)\n  this.graphics.fillStyle(0x00ff00, 1);\n  this.graphics.fillRect(0, 0, 400, 32);\n  this.graphics.generateTexture('platform', 400, 32);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // Create platforms using a static physics group\n  this.platforms = this.physics.add.staticGroup();\n  // Ground platform (stretched to cover the bottom)\n  this.platforms.create(400, 584, 'platform').setScale(2).refreshBody();\n  // Additional platforms\n  this.platforms.create(600, 400, 'platform');\n  this.platforms.create(50, 250, 'platform');\n  this.platforms.create(750, 220, 'platform');\n\n  // Create the player sprite and enable physics\n  this.player = this.physics.add.sprite(100, 450, 'player');\n  this.player.setBounce(0.2);\n  this.player.setCollideWorldBounds(true);\n\n  // Create enemies group and add multiple enemies\n  this.enemies = this.physics.add.group();\n  // Enemy 1\n  let enemy1 = this.enemies.create(700, 450, 'enemy');\n  enemy1.setBounce(1);\n  enemy1.setCollideWorldBounds(true);\n  enemy1.setVelocityX(-100);\n  // Enemy 2\n  let enemy2 = this.enemies.create(400, 300, 'enemy');\n  enemy2.setBounce(1);\n  enemy2.setCollideWorldBounds(true);\n  enemy2.setVelocityX(80);\n  // Enemy 3\n  let enemy3 = this.enemies.create(600, 150, 'enemy');\n  enemy3.setBounce(1);\n  enemy3.setCollideWorldBounds(true);\n  enemy3.setVelocityX(-120);\n\n  // Enable collisions between the player/enemies and the platforms\n  this.physics.add.collider(this.player, this.platforms);\n  this.physics.add.collider(this.enemies, this.platforms);\n\n  // When an enemy overlaps the player, trigger the question routine (with cooldown check)\n  this.physics.add.overlap(this.player, this.enemies, onEnemyHit, null, this);\n\n  // Set up keyboard controls for player movement\n  this.cursors = this.input.keyboard.createCursorKeys();\n\n  // Create score text\n  scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '20px', fill: '#000' });\n  \n  // Create level text\n  levelText = this.add.text(16, 40, 'Level: 1', { fontSize: '20px', fill: '#000' });\n\n  // Create a text object for showing the result (used for question feedback)\n  this.resultText = this.add.text(400, 350, '', { font: '24px Arial', fill: '#000' }).setOrigin(0.5);\n\n  // Listen for keyboard events (for answering binary questions)\n  this.input.keyboard.on('keydown', handleKeyPress, this);\n}\n\nfunction update() {\n  if (!questionActive) {\n    // --- Player movement logic ---\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-330);\n    }\n\n    // --- Enemy patrol logic ---\n    this.enemies.getChildren().forEach(enemy => {\n      if (enemy.body.blocked.left) {\n        enemy.setVelocityX(Math.abs(enemy.body.velocity.x));\n      } else if (enemy.body.blocked.right) {\n        enemy.setVelocityX(-Math.abs(enemy.body.velocity.x));\n      }\n    });\n\n    // --- Level progression logic ---\n    // If the player reaches near the top of the screen, advance to the next level.\n    if (this.player.y < 50) {\n      nextLevel(this);\n    }\n  }\n}\n\n// This function is called when an enemy hits the player.\nfunction onEnemyHit(player, enemy) {\n  // Check if we're already in cooldown\n  if (hitCooldown || questionActive) {\n    return;\n  }\n  \n  // Set the cooldown flag\n  hitCooldown = true;\n  \n  // Trigger the question routine.\n  questionActive = true;\n  // Pause the physics to \"freeze\" the game during the question.\n  this.physics.pause();\n  generateBinaryQuestion(this);\n  \n  // Set a timer to remove the cooldown after 2 seconds (2000 milliseconds).\n  this.time.delayedCall(2000, () => {\n    hitCooldown = false;\n  });\n}\n\n// This function generates and displays a binary multiplication question.\nfunction generateBinaryQuestion(scene) {\n  // Generate two random numbers (1 to 15) and convert them to binary strings.\n  const a = Phaser.Math.Between(1, 15);\n  const b = Phaser.Math.Between(1, 15);\n  const aBinary = a.toString(2);\n  const bBinary = b.toString(2);\n  correctAnswer = a * b;\n\n  // Display the question in the center of the screen.\n  questionText = scene.add.text(\n    400,\n    200,\n    `What is ${aBinary} * ${bBinary} in binary?`,\n    { font: '24px Arial', fill: '#000' }\n  ).setOrigin(0.5);\n\n  // Create three answer options: the correct answer, one more, and one less.\n  currentAnswers = [\n    correctAnswer.toString(2),\n    (correctAnswer + 1).toString(2),\n    (correctAnswer - 1).toString(2)\n  ];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n\n  // Display the answer options.\n  answerTexts = [];\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let optionText = scene.add.text(\n      400,\n      250 + i * 40,\n      `${i + 1}: ${currentAnswers[i]}`,\n      { font: '24px Arial', fill: '#000' }\n    ).setOrigin(0.5);\n    answerTexts.push(optionText);\n  }\n}\n\n// This function handles key presses for answering the question.\nfunction handleKeyPress(event) {\n  // Only process input if a question is active.\n  if (!questionActive) {\n    return;\n  }\n  // Check if the pressed key is '1', '2', or '3'.\n  const keyIndex = parseInt(event.key) - 1;\n  if (keyIndex >= 0 && keyIndex < currentAnswers.length) {\n    // Convert the chosen binary answer to an integer.\n    const selectedAnswer = parseInt(currentAnswers[keyIndex], 2);\n    if (selectedAnswer === correctAnswer) {\n      // Correct answer.\n      this.resultText.setText('Correct!');\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    } else {\n      // Incorrect answer.\n      this.resultText.setText('Incorrect, try again!');\n      mistakes.push(`Mistake: Selected ${currentAnswers[keyIndex]} instead of ${correctAnswer.toString(2)}`);\n      console.log(mistakes);\n      // Reset the question after a short delay to allow another try.\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    }\n  }\n}\n\n// This function removes the question UI and resumes the game.\nfunction resetQuestion(scene) {\n  if (questionText) {\n    questionText.destroy();\n  }\n  answerTexts.forEach(text => text.destroy());\n  scene.resultText.setText('');\n  questionActive = false;\n  // Resume physics so the game continues.\n  scene.physics.resume();\n}\n\n// This function advances the game to the next level.\nfunction nextLevel(scene) {\n  // Increase the level counter and update the display.\n  level++;\n  levelText.setText('Level: ' + level);\n  \n  // Optionally, add a new enemy to increase the challenge.\n  let newEnemyX = Phaser.Math.Between(50, 750);\n  let newEnemyY = Phaser.Math.Between(50, 300);\n  let newEnemy = scene.enemies.create(newEnemyX, newEnemyY, 'enemy');\n  newEnemy.setBounce(1);\n  newEnemy.setCollideWorldBounds(true);\n  // Set a random horizontal velocity between 100 and 150 (with a random direction).\n  let velocityX = Phaser.Math.Between(100, 150);\n  if (Phaser.Math.Between(0, 1)) {\n    velocityX = -velocityX;\n  }\n  newEnemy.setVelocityX(velocityX);\n\n  // Reset the player's position to the bottom of the screen.\n  scene.player.setPosition(100, 450);\n}\n",
      "timestamp": "2025-02-04T12:25:56.203Z",
      "totalPoints": 0
    },
    {
      "id": "8b7daa57-2c3f-4b2b-8c24-7aae2fa6f7fb",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#b3e5fc',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for binary question UI, score, level, and cooldown\nlet currentAnswers = [];\nlet correctAnswer = 0;\nlet questionActive = false;\nlet questionText;\nlet answerTexts = [];\nlet score = 0;\nlet scoreText;\nlet mistakes = [];\nlet level = 1;\nlet levelText;\nlet hitCooldown = false; // cooldown flag to prevent multiple hits\n\nfunction preload() {\n  // Create a graphics object for drawing textures\n  this.graphics = this.add.graphics();\n\n  // Create a simple player texture (blue rectangle)\n  this.graphics.fillStyle(0x0000ff, 1);\n  this.graphics.fillRect(0, 0, 32, 48);\n  this.graphics.generateTexture('player', 32, 48);\n  this.graphics.clear();\n\n  // Create a simple enemy texture (red rectangle)\n  this.graphics.fillStyle(0xff0000, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('enemy', 32, 32);\n  this.graphics.clear();\n\n  // Create a platform texture (green rectangle)\n  this.graphics.fillStyle(0x00ff00, 1);\n  this.graphics.fillRect(0, 0, 400, 32);\n  this.graphics.generateTexture('platform', 400, 32);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // Create platforms using a static physics group\n  this.platforms = this.physics.add.staticGroup();\n  // Ground platform (stretched to cover the bottom)\n  this.platforms.create(400, 584, 'platform').setScale(2).refreshBody();\n  // Additional platforms\n  this.platforms.create(600, 400, 'platform');\n  this.platforms.create(50, 250, 'platform');\n  this.platforms.create(750, 220, 'platform');\n\n  // Create the player sprite and enable physics\n  this.player = this.physics.add.sprite(100, 450, 'player');\n  this.player.setBounce(0.2);\n  this.player.setCollideWorldBounds(true);\n\n  // Create enemies group and add multiple enemies\n  this.enemies = this.physics.add.group();\n  // Enemy 1\n  let enemy1 = this.enemies.create(700, 450, 'enemy');\n  enemy1.setBounce(1);\n  enemy1.setCollideWorldBounds(true);\n  enemy1.setVelocityX(-100);\n  // Enemy 2\n  let enemy2 = this.enemies.create(400, 300, 'enemy');\n  enemy2.setBounce(1);\n  enemy2.setCollideWorldBounds(true);\n  enemy2.setVelocityX(80);\n  // Enemy 3\n  let enemy3 = this.enemies.create(600, 150, 'enemy');\n  enemy3.setBounce(1);\n  enemy3.setCollideWorldBounds(true);\n  enemy3.setVelocityX(-120);\n\n  // Enable collisions between the player/enemies and the platforms\n  this.physics.add.collider(this.player, this.platforms);\n  this.physics.add.collider(this.enemies, this.platforms);\n\n  // When an enemy overlaps the player, trigger the question routine (with cooldown check)\n  this.physics.add.overlap(this.player, this.enemies, onEnemyHit, null, this);\n\n  // Set up keyboard controls for player movement\n  this.cursors = this.input.keyboard.createCursorKeys();\n\n  // Create score text\n  scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '20px', fill: '#000' });\n  \n  // Create level text\n  levelText = this.add.text(16, 40, 'Level: 1', { fontSize: '20px', fill: '#000' });\n\n  // Create a text object for showing the result (used for question feedback)\n  this.resultText = this.add.text(400, 350, '', { font: '24px Arial', fill: '#000' }).setOrigin(0.5);\n\n  // Listen for keyboard events (for answering binary questions)\n  this.input.keyboard.on('keydown', handleKeyPress, this);\n}\n\nfunction update() {\n  if (!questionActive) {\n    // --- Player movement logic ---\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-330);\n    }\n\n    // --- Enemy patrol logic ---\n    this.enemies.getChildren().forEach(enemy => {\n      if (enemy.body.blocked.left) {\n        enemy.setVelocityX(Math.abs(enemy.body.velocity.x));\n      } else if (enemy.body.blocked.right) {\n        enemy.setVelocityX(-Math.abs(enemy.body.velocity.x));\n      }\n    });\n\n    // --- Level progression logic ---\n    // If the player reaches near the top of the screen, advance to the next level.\n    if (this.player.y < 50) {\n      nextLevel(this);\n    }\n  }\n}\n\n// This function is called when an enemy hits the player.\nfunction onEnemyHit(player, enemy) {\n  // Check if we're already in cooldown\n  if (hitCooldown || questionActive) {\n    return;\n  }\n  \n  // Set the cooldown flag\n  hitCooldown = true;\n  \n  // Trigger the question routine.\n  questionActive = true;\n  // Pause the physics to \"freeze\" the game during the question.\n  this.physics.pause();\n  generateBinaryQuestion(this);\n  \n  // Set a timer to remove the cooldown after 2 seconds (2000 milliseconds).\n  this.time.delayedCall(2000, () => {\n    hitCooldown = false;\n  });\n}\n\n// This function generates and displays a binary multiplication question.\nfunction generateBinaryQuestion(scene) {\n  // Generate two random numbers (1 to 15) and convert them to binary strings.\n  const a = Phaser.Math.Between(1, 15);\n  const b = Phaser.Math.Between(1, 15);\n  const aBinary = a.toString(2);\n  const bBinary = b.toString(2);\n  correctAnswer = a * b;\n\n  // Display the question in the center of the screen.\n  questionText = scene.add.text(\n    400,\n    200,\n    `What is ${aBinary} * ${bBinary} in binary?`,\n    { font: '24px Arial', fill: '#000' }\n  ).setOrigin(0.5);\n\n  // Create three answer options: the correct answer, one more, and one less.\n  currentAnswers = [\n    correctAnswer.toString(2),\n    (correctAnswer + 1).toString(2),\n    (correctAnswer - 1).toString(2)\n  ];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n\n  // Display the answer options.\n  answerTexts = [];\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let optionText = scene.add.text(\n      400,\n      250 + i * 40,\n      `${i + 1}: ${currentAnswers[i]}`,\n      { font: '24px Arial', fill: '#000' }\n    ).setOrigin(0.5);\n    answerTexts.push(optionText);\n  }\n}\n\n// This function handles key presses for answering the question.\nfunction handleKeyPress(event) {\n  // Only process input if a question is active.\n  if (!questionActive) {\n    return;\n  }\n  // Check if the pressed key is '1', '2', or '3'.\n  const keyIndex = parseInt(event.key) - 1;\n  if (keyIndex >= 0 && keyIndex < currentAnswers.length) {\n    // Convert the chosen binary answer to an integer.\n    const selectedAnswer = parseInt(currentAnswers[keyIndex], 2);\n    if (selectedAnswer === correctAnswer) {\n      // Correct answer.\n      this.resultText.setText('Correct!');\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    } else {\n      // Incorrect answer.\n      this.resultText.setText('Incorrect, try again!');\n      mistakes.push(`Mistake: Selected ${currentAnswers[keyIndex]} instead of ${correctAnswer.toString(2)}`);\n      console.log(mistakes);\n      // Reset the question after a short delay to allow another try.\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    }\n  }\n}\n\n// This function removes the question UI and resumes the game.\nfunction resetQuestion(scene) {\n  if (questionText) {\n    questionText.destroy();\n  }\n  answerTexts.forEach(text => text.destroy());\n  scene.resultText.setText('');\n  questionActive = false;\n  // Resume physics so the game continues.\n  scene.physics.resume();\n}\n\n// This function advances the game to the next level.\nfunction nextLevel(scene) {\n  // Increase the level counter and update the display.\n  level++;\n  levelText.setText('Level: ' + level);\n  \n  // Optionally, add a new enemy to increase the challenge.\n  let newEnemyX = Phaser.Math.Between(50, 750);\n  let newEnemyY = Phaser.Math.Between(50, 300);\n  let newEnemy = scene.enemies.create(newEnemyX, newEnemyY, 'enemy');\n  newEnemy.setBounce(1);\n  newEnemy.setCollideWorldBounds(true);\n  // Set a random horizontal velocity between 100 and 150 (with a random direction).\n  let velocityX = Phaser.Math.Between(100, 150);\n  if (Phaser.Math.Between(0, 1)) {\n    velocityX = -velocityX;\n  }\n  newEnemy.setVelocityX(velocityX);\n\n  // Reset the player's position to the bottom of the screen.\n  scene.player.setPosition(100, 450);\n}\n",
      "timestamp": "2025-02-04T12:28:39.199Z",
      "totalPoints": 0
    },
    {
      "id": "782501cb-b602-46ca-8a8c-29d0ce73bbfe",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#b3e5fc',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 300 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for binary question UI, score, level, and cooldown\nlet currentAnswers = [];\nlet correctAnswer = 0;\nlet questionActive = false;\nlet questionText;\nlet answerTexts = [];\nlet score = 0;\nlet scoreText;\nlet mistakes = [];\nlet level = 1;\nlet levelText;\nlet hitCooldown = false; // cooldown flag to prevent multiple hits\n\nfunction preload() {\n  // Create a graphics object for drawing textures\n  this.graphics = this.add.graphics();\n\n  // Create a simple player texture (blue rectangle)\n  this.graphics.fillStyle(0x0000ff, 1);\n  this.graphics.fillRect(0, 0, 32, 48);\n  this.graphics.generateTexture('player', 32, 48);\n  this.graphics.clear();\n\n  // Create a simple enemy texture (red rectangle)\n  this.graphics.fillStyle(0xff0000, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('enemy', 32, 32);\n  this.graphics.clear();\n\n  // Create a platform texture (green rectangle)\n  this.graphics.fillStyle(0x00ff00, 1);\n  this.graphics.fillRect(0, 0, 400, 32);\n  this.graphics.generateTexture('platform', 400, 32);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // Create platforms using a static physics group\n  this.platforms = this.physics.add.staticGroup();\n  // Ground platform (stretched to cover the bottom)\n  this.platforms.create(400, 584, 'platform').setScale(2).refreshBody();\n  // Additional platforms\n  this.platforms.create(600, 400, 'platform');\n  this.platforms.create(50, 250, 'platform');\n  this.platforms.create(750, 220, 'platform');\n\n  // Create the player sprite and enable physics\n  this.player = this.physics.add.sprite(100, 450, 'player');\n  this.player.setBounce(0.2);\n  this.player.setCollideWorldBounds(true);\n\n  // Create enemies group and add multiple enemies\n  this.enemies = this.physics.add.group();\n  // Enemy 1\n  let enemy1 = this.enemies.create(700, 450, 'enemy');\n  enemy1.setBounce(1);\n  enemy1.setCollideWorldBounds(true);\n  enemy1.setVelocityX(-100);\n  // Enemy 2\n  let enemy2 = this.enemies.create(400, 300, 'enemy');\n  enemy2.setBounce(1);\n  enemy2.setCollideWorldBounds(true);\n  enemy2.setVelocityX(80);\n  // Enemy 3\n  let enemy3 = this.enemies.create(600, 150, 'enemy');\n  enemy3.setBounce(1);\n  enemy3.setCollideWorldBounds(true);\n  enemy3.setVelocityX(-120);\n\n  // Enable collisions between the player/enemies and the platforms\n  this.physics.add.collider(this.player, this.platforms);\n  this.physics.add.collider(this.enemies, this.platforms);\n\n  // When an enemy overlaps the player, trigger the question routine (with cooldown check)\n  this.physics.add.overlap(this.player, this.enemies, onEnemyHit, null, this);\n\n  // Set up keyboard controls for player movement\n  this.cursors = this.input.keyboard.createCursorKeys();\n\n  // Create score text\n  scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '20px', fill: '#000' });\n  \n  // Create level text\n  levelText = this.add.text(16, 40, 'Level: 1', { fontSize: '20px', fill: '#000' });\n\n  // Create a text object for showing the result (used for question feedback)\n  this.resultText = this.add.text(400, 350, '', { font: '24px Arial', fill: '#000' }).setOrigin(0.5);\n\n  // Listen for keyboard events (for answering binary questions)\n  this.input.keyboard.on('keydown', handleKeyPress, this);\n}\n\nfunction update() {\n  if (!questionActive) {\n    // --- Player movement logic ---\n    if (this.cursors.left.isDown) {\n      this.player.setVelocityX(-160);\n    } else if (this.cursors.right.isDown) {\n      this.player.setVelocityX(160);\n    } else {\n      this.player.setVelocityX(0);\n    }\n    if (this.cursors.up.isDown && this.player.body.touching.down) {\n      this.player.setVelocityY(-330);\n    }\n\n    // --- Enemy patrol logic ---\n    this.enemies.getChildren().forEach(enemy => {\n      if (enemy.body.blocked.left) {\n        enemy.setVelocityX(Math.abs(enemy.body.velocity.x));\n      } else if (enemy.body.blocked.right) {\n        enemy.setVelocityX(-Math.abs(enemy.body.velocity.x));\n      }\n    });\n\n    // --- Level progression logic ---\n    // If the player reaches near the top of the screen, advance to the next level.\n    if (this.player.y < 50) {\n      nextLevel(this);\n    }\n  }\n}\n\n// This function is called when an enemy hits the player.\nfunction onEnemyHit(player, enemy) {\n  // Check if we're already in cooldown\n  if (hitCooldown || questionActive) {\n    return;\n  }\n  \n  // Set the cooldown flag\n  hitCooldown = true;\n  \n  // Trigger the question routine.\n  questionActive = true;\n  // Pause the physics to \"freeze\" the game during the question.\n  this.physics.pause();\n  generateBinaryQuestion(this);\n  \n  // Set a timer to remove the cooldown after 2 seconds (2000 milliseconds).\n  this.time.delayedCall(2000, () => {\n    hitCooldown = false;\n  });\n}\n\n// This function generates and displays a binary multiplication question.\nfunction generateBinaryQuestion(scene) {\n  // Generate two random numbers (1 to 15) and convert them to binary strings.\n  const a = Phaser.Math.Between(1, 15);\n  const b = Phaser.Math.Between(1, 15);\n  const aBinary = a.toString(2);\n  const bBinary = b.toString(2);\n  correctAnswer = a * b;\n\n  // Display the question in the center of the screen.\n  questionText = scene.add.text(\n    400,\n    200,\n    `What is ${aBinary} * ${bBinary} in binary?`,\n    { font: '24px Arial', fill: '#000' }\n  ).setOrigin(0.5);\n\n  // Create three answer options: the correct answer, one more, and one less.\n  currentAnswers = [\n    correctAnswer.toString(2),\n    (correctAnswer + 1).toString(2),\n    (correctAnswer - 1).toString(2)\n  ];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n\n  // Display the answer options.\n  answerTexts = [];\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let optionText = scene.add.text(\n      400,\n      250 + i * 40,\n      `${i + 1}: ${currentAnswers[i]}`,\n      { font: '24px Arial', fill: '#000' }\n    ).setOrigin(0.5);\n    answerTexts.push(optionText);\n  }\n}\n\n// This function handles key presses for answering the question.\nfunction handleKeyPress(event) {\n  // Only process input if a question is active.\n  if (!questionActive) {\n    return;\n  }\n  // Check if the pressed key is '1', '2', or '3'.\n  const keyIndex = parseInt(event.key) - 1;\n  if (keyIndex >= 0 && keyIndex < currentAnswers.length) {\n    // Convert the chosen binary answer to an integer.\n    const selectedAnswer = parseInt(currentAnswers[keyIndex], 2);\n    if (selectedAnswer === correctAnswer) {\n      // Correct answer.\n      this.resultText.setText('Correct!');\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    } else {\n      // Incorrect answer.\n      this.resultText.setText('Incorrect, try again!');\n      mistakes.push(`Mistake: Selected ${currentAnswers[keyIndex]} instead of ${correctAnswer.toString(2)}`);\n      console.log(mistakes);\n      // Reset the question after a short delay to allow another try.\n      setTimeout(() => {\n        resetQuestion(this);\n      }, 500);\n    }\n  }\n}\n\n// This function removes the question UI and resumes the game.\nfunction resetQuestion(scene) {\n  if (questionText) {\n    questionText.destroy();\n  }\n  answerTexts.forEach(text => text.destroy());\n  scene.resultText.setText('');\n  questionActive = false;\n  // Resume physics so the game continues.\n  scene.physics.resume();\n}\n\n// This function advances the game to the next level.\nfunction nextLevel(scene) {\n  // Increase the level counter and update the display.\n  level++;\n  levelText.setText('Level: ' + level);\n  \n  // Optionally, add a new enemy to increase the challenge.\n  let newEnemyX = Phaser.Math.Between(50, 750);\n  let newEnemyY = Phaser.Math.Between(50, 300);\n  let newEnemy = scene.enemies.create(newEnemyX, newEnemyY, 'enemy');\n  newEnemy.setBounce(1);\n  newEnemy.setCollideWorldBounds(true);\n  // Set a random horizontal velocity between 100 and 150 (with a random direction).\n  let velocityX = Phaser.Math.Between(100, 150);\n  if (Phaser.Math.Between(0, 1)) {\n    velocityX = -velocityX;\n  }\n  newEnemy.setVelocityX(velocityX);\n\n  // Reset the player's position to the bottom of the screen.\n  scene.player.setPosition(100, 450);\n}\n",
      "timestamp": "2025-02-04T12:30:28.803Z",
      "totalPoints": 0
    },
    {
      "id": "31b221ca-2ae5-42d2-b135-600abd18fe45",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#f5f5f5',\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for our simulation\nlet processes = []; // Array of waiting processes\nlet nextProcessId = 1;\nlet score = 0;\nlet scoreText;\nlet instructionText;\nlet cpuText;\nlet processGroup;\n\nfunction preload() {\n  // No external assets in this demo.\n}\n\nfunction create() {\n  // Create a group to hold process display objects.\n  processGroup = this.add.group();\n\n  // Display score and instructions.\n  scoreText = this.add.text(16, 16, 'Score: 0', { font: '20px Arial', fill: '#000' });\n  instructionText = this.add.text(\n    16,\n    50,\n    'Select the process with the shortest burst time (SJF) by pressing 1, 2, 3, ...',\n    { font: '16px Arial', fill: '#000' }\n  );\n  \n  // Display CPU area in the middle.\n  cpuText = this.add.text(400, 300, 'CPU Idle', { font: '24px Arial', fill: '#d32f2f' }).setOrigin(0.5);\n\n  // Generate the initial waiting queue of processes.\n  generateProcesses(this);\n\n  // Listen for keyboard events (number keys for selection).\n  this.input.keyboard.on('keydown', handleKey, this);\n}\n\nfunction update() {\n  // In this simulation, our logic is event-driven (no per-frame updates needed).\n}\n\n/**\n * Generates a new set of processes with random burst times.\n * Each process is represented as an object with an id and burstTime.\n * The processes are displayed as rectangles with labels.\n */\nfunction generateProcesses(scene) {\n  // Clear any existing process display objects.\n  processGroup.clear(true, true);\n  processes = [];\n  \n  // Generate between 3 and 5 processes.\n  const numProcesses = Phaser.Math.Between(3, 5);\n  for (let i = 0; i < numProcesses; i++) {\n    const burst = Phaser.Math.Between(2, 10);\n    let proc = {\n      id: nextProcessId++,\n      burstTime: burst\n    };\n    processes.push(proc);\n  }\n  \n  // Sort processes by id (so the order of display is consistent).\n  processes.sort((a, b) => a.id - b.id);\n\n  // Display each process in a \"waiting queue\" area.\n  for (let i = 0; i < processes.length; i++) {\n    let proc = processes[i];\n    // Set a display position for the process.\n    let x = 100 + i * 150;\n    let y = 100;\n    \n    // Draw a rectangle to represent the process.\n    let rect = scene.add.rectangle(x, y, 120, 80, 0x90caf9).setOrigin(0.5);\n    // Add text inside the rectangle with process id and burst time.\n    let text = scene.add.text(x, y, `P${proc.id}\\nBurst: ${proc.burstTime}`, {\n      font: '20px Arial',\n      fill: '#000',\n      align: 'center'\n    }).setOrigin(0.5);\n    // Add an index label (for selection via number keys) near the rectangle.\n    let indexText = scene.add.text(x - 50, y - 30, `${i + 1}`, {\n      font: '24px Arial',\n      fill: '#d32f2f'\n    });\n    \n    // Save references to these display objects in the process object.\n    proc.rect = rect;\n    proc.text = text;\n    proc.indexText = indexText;\n    \n    // Add these objects to the group.\n    processGroup.addMultiple([rect, text, indexText]);\n  }\n}\n\n/**\n * Handles keyboard input.\n * When the player presses a number key, the corresponding process in the waiting queue is selected.\n * The correct process is the one with the smallest burst time.\n */\nfunction handleKey(event) {\n  // Convert the pressed key to an index (assuming keys \"1\", \"2\", \"3\", etc.).\n  let index = parseInt(event.key) - 1;\n  if (isNaN(index)) return;\n  if (index < 0 || index >= processes.length) return;\n\n  // Determine the correct process (one with the shortest burst time).\n  let correctProcess = processes.reduce((prev, curr) => (curr.burstTime < prev.burstTime ? curr : prev), processes[0]);\n  \n  let selectedProcess = processes[index];\n\n  if (selectedProcess === correctProcess) {\n    // Correct selection: simulate the process running in the CPU.\n    cpuText.setText(`CPU Running P${selectedProcess.id}`);\n    score += 10;\n    scoreText.setText('Score: ' + score);\n\n    // Remove the selected process's display objects with a small delay.\n    selectedProcess.rect.destroy();\n    selectedProcess.text.destroy();\n    selectedProcess.indexText.destroy();\n\n    // Remove it from the waiting queue array.\n    processes.splice(index, 1);\n\n    // Simulate the process run time (1 second delay).\n    this.time.delayedCall(1000, () => {\n      cpuText.setText('CPU Idle');\n      // If no processes remain, generate a new batch.\n      if (processes.length === 0) {\n        generateProcesses(this);\n      } else {\n        // Re-label and re-position the remaining processes for clarity.\n        for (let i = 0; i < processes.length; i++) {\n          processes[i].indexText.setText(`${i + 1}`);\n          let newX = 100 + i * 150;\n          processes[i].rect.x = newX;\n          processes[i].text.x = newX;\n          processes[i].indexText.x = newX - 50;\n        }\n      }\n    }, [], this);\n  } else {\n    // Incorrect selection: show an error message.\n    cpuText.setText('Incorrect! Try Again.');\n    this.time.delayedCall(1000, () => {\n      cpuText.setText('CPU Idle');\n    }, [], this);\n  }\n}\n",
      "timestamp": "2025-02-04T12:30:33.035Z",
      "totalPoints": 0
    },
    {
      "id": "4e300291-3f3d-479a-8696-777966ec140c",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#e8f5e9',\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global variables for the IEEE754 Quest\nlet currentAnswers = [];\nlet correctAnswer = '';\nlet questionActive = false;\nlet questionText;\nlet answerTexts = [];\nlet score = 0;\nlet scoreText;\nlet currentNumber = 0;\n\nfunction preload() {\n  // No external assets are needed.\n}\n\nfunction create() {\n  // Display the current score.\n  scoreText = this.add.text(16, 16, 'Score: 0', { font: '20px Arial', fill: '#000' });\n\n  // Create the question text (centered near the top).\n  questionText = this.add.text(400, 150, '', { font: '24px Arial', fill: '#000' }).setOrigin(0.5);\n\n  // Listen for number key inputs (for selecting the answer options).\n  this.input.keyboard.on('keydown', handleKey, this);\n\n  // Generate the first IEEE754 question.\n  generateIEEE754Question(this);\n}\n\nfunction update() {\n  // No per-frame logic is needed; this game is event-driven.\n}\n\n/**\n * Generates a new question by picking a random float, converting it to IEEE754,\n * generating two distractors by altering one random bit, shuffling the options,\n * and then displaying the question and answers.\n */\nfunction generateIEEE754Question(scene) {\n  // Generate a random float between -50 and 50 (rounded to 2 decimals).\n  currentNumber = Phaser.Math.FloatBetween(-50, 50);\n  currentNumber = parseFloat(currentNumber.toFixed(2));\n\n  // Compute the correct IEEE754 (32-bit) representation.\n  correctAnswer = floatToIEEE754(currentNumber);\n\n  // Create two distractors by flipping a random bit in the correct answer.\n  let distractor1 = alterBit(correctAnswer);\n  let distractor2 = alterBit(correctAnswer);\n\n  // Ensure that the distractors differ from the correct answer and from each other.\n  while (distractor1 === correctAnswer) {\n    distractor1 = alterBit(correctAnswer);\n  }\n  while (distractor2 === correctAnswer || distractor2 === distractor1) {\n    distractor2 = alterBit(correctAnswer);\n  }\n\n  // Create an array of answer options and shuffle them.\n  currentAnswers = [correctAnswer, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n\n  // Update the question text.\n  questionText.setText(`Convert ${currentNumber} to IEEE754 (32-bit):`);\n\n  // Remove any previous answer texts.\n  if (answerTexts.length > 0) {\n    answerTexts.forEach(text => text.destroy());\n    answerTexts = [];\n  }\n\n  // Display the answer options (with labels 1, 2, 3).\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let option = scene.add.text(400, 250 + i * 50, `${i + 1}: ${currentAnswers[i]}`, {\n      font: '20px Arial',\n      fill: '#000'\n    }).setOrigin(0.5);\n    answerTexts.push(option);\n  }\n\n  questionActive = true;\n}\n\n/**\n * Handles number key presses.\n * If the correct answer is chosen, the score increases; otherwise, a message is shown.\n * After a short delay, a new question is generated.\n */\nfunction handleKey(event) {\n  if (!questionActive) return;\n\n  // Convert the key to an index (assuming keys \"1\", \"2\", \"3\", etc.).\n  const index = parseInt(event.key) - 1;\n  if (index < 0 || index >= currentAnswers.length) return;\n\n  const selectedAnswer = currentAnswers[index];\n\n  if (selectedAnswer === correctAnswer) {\n    score += 10;\n    scoreText.setText('Score: ' + score);\n    questionText.setText('Correct!');\n  } else {\n    questionText.setText('Incorrect!');\n  }\n\n  questionActive = false;\n  // Wait 1 second, then generate a new question.\n  this.time.delayedCall(1000, () => {\n    generateIEEE754Question(this);\n  }, [], this);\n}\n\n/**\n * Converts a floating-point number to its IEEE754 32-bit binary representation.\n * Uses a Float32Array and a Uint32Array to extract the underlying bits.\n */\nfunction floatToIEEE754(num) {\n  let f32 = new Float32Array(1);\n  f32[0] = num;\n  let u32 = new Uint32Array(f32.buffer);\n  // Convert to a binary string, padded to 32 bits.\n  return u32[0].toString(2).padStart(32, '0');\n}\n\n/**\n * Flips a random bit in a 32-bit binary string.\n * This function returns a new string with one bit toggled.\n */\nfunction alterBit(binaryStr) {\n  // Pick a random index between 0 and 31.\n  const index = Phaser.Math.Between(0, 31);\n  // Determine the new bit value.\n  const newBit = binaryStr[index] === '0' ? '1' : '0';\n  // Return the string with the bit at the selected index flipped.\n  return binaryStr.substr(0, index) + newBit + binaryStr.substr(index + 1);\n}\n",
      "timestamp": "2025-02-04T12:39:21.209Z",
      "totalPoints": 0
    },
    {
      "id": "5578e0ba-55df-4560-8689-d0dea4ef36cf",
      "name": "Binary Multiplication Game",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#eceff1',\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global game variables\nlet puzzleStage = 1; // 1 for door lock; 2 for safe lock\nlet score = 0;\nlet scoreText;\nlet narrativeText;\nlet optionTexts = [];\nlet correctAnswer = '';\nlet currentAnswers = [];\n\n// Variables for Lock 1 (Door Lock: 2's Complement)\nlet lock1Number;      // a random negative integer between -128 and -1\nlet lock1Correct;     // its correct 8-bit 2's complement representation\n\n// Variables for Lock 2 (Safe Lock: Division Puzzle)\nlet ieee754Str;       // a 32-bit IEEE754 binary string\nlet ieee754Value;     // the float value decoded from ieee754Str\nlet divisionResult;   // result of lock1Number / ieee754Value (rounded)\n\nfunction preload() {\n  // No external assets needed.\n}\n\nfunction create() {\n  // Display score at the top-left.\n  scoreText = this.add.text(16, 16, 'Score: 0', { font: '20px Arial', fill: '#000' });\n  // Narrative/instruction text (centered near the top)\n  narrativeText = this.add.text(400, 80, '', { font: '22px Arial', fill: '#000', align: 'center', wordWrap: { width: 750 } }).setOrigin(0.5);\n  \n  // Listen for number key inputs.\n  this.input.keyboard.on('keydown', handleKey, this);\n  \n  // Start with Lock 1\n  setupLock1(this);\n}\n\nfunction update() {\n  // No per-frame logic needed; the game is event-driven.\n}\n\n/* --------------------------\n   LOCK 1: Door Lock Puzzle\n   --------------------------\n   Puzzle: Convert a negative decimal number to its 8-bit 2's complement representation.\n   Example: If lock1Number = -5, then 2's complement (8-bit) is 11111011.\n*/\nfunction setupLock1(scene) {\n  puzzleStage = 1;\n  // Clear any old options.\n  clearOptions();\n  \n  // Generate a random negative integer between -128 and -1.\n  lock1Number = Phaser.Math.Between(-128, -1);\n  // Compute 8-bit 2's complement: For a negative number, add 256.\n  let twosValue = 256 + lock1Number; // This is an integer between 128 and 255.\n  lock1Correct = twosValue.toString(2).padStart(8, '0'); // 8-bit binary string.\n  \n  // Generate two distractors by flipping one random bit.\n  let distractor1 = alterBit(lock1Correct);\n  let distractor2 = alterBit(lock1Correct);\n  // Make sure distractors differ from correct and from each other.\n  while (distractor1 === lock1Correct) {\n    distractor1 = alterBit(lock1Correct);\n  }\n  while (distractor2 === lock1Correct || distractor2 === distractor1) {\n    distractor2 = alterBit(lock1Correct);\n  }\n  \n  currentAnswers = [lock1Correct, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  // Update narrative text.\n  narrativeText.setText(\n    `You approach a heavy door lock.\\n\\n` +\n    `A panel displays the decimal number:\\n  ${lock1Number}\\n\\n` +\n    `To pop the lock, convert this number into its 8-bit 2's complement representation.`\n  );\n  \n  // Display answer options.\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let opt = scene.add.text(400, 250 + i * 60, `${i + 1}: ${currentAnswers[i]}`, {\n      font: '22px Arial',\n      fill: '#3e2723'\n    }).setOrigin(0.5);\n    optionTexts.push(opt);\n  }\n}\n\n/* --------------------------\n   LOCK 2: Safe Lock Puzzle\n   --------------------------\n   Puzzle: Divide the number from Lock 1 (lock1Number) by a random positive number.\n   The positive number is given in IEEE754 32-bit binary string form.\n   You must decode it and then compute (lock1Number / decoded value), rounded to two decimals.\n*/\nfunction setupLock2(scene) {\n  puzzleStage = 2;\n  clearOptions();\n  \n  // Generate a random positive float between 1 and 20.\n  let randomFloat = Phaser.Math.FloatBetween(1, 20);\n  // Round for display purposes.\n  randomFloat = parseFloat(randomFloat.toFixed(2));\n  \n  // Convert it to IEEE754 32-bit binary representation.\n  ieee754Str = floatToIEEE754(randomFloat);\n  ieee754Value = randomFloat; // For clarity.\n  \n  // Compute the division: (lock1Number) divided by (randomFloat).\n  // Note: lock1Number is negative.\n  divisionResult = (lock1Number / randomFloat).toFixed(2);\n  \n  // Generate two distractor answers by adding/subtracting a small random offset.\n  let offset1 = (Phaser.Math.FloatBetween(0.1, 1)).toFixed(2);\n  let offset2 = (Phaser.Math.FloatBetween(0.1, 1)).toFixed(2);\n  \n  // Randomly decide to add or subtract.\n  let distractor1 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? +offset1 : -offset1)).toFixed(2);\n  let distractor2 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? +offset2 : -offset2)).toFixed(2);\n  \n  // Ensure uniqueness.\n  if (distractor1 === divisionResult) distractor1 = (parseFloat(divisionResult) + 0.1).toFixed(2);\n  if (distractor2 === divisionResult || distractor2 === distractor1) distractor2 = (parseFloat(divisionResult) - 0.1).toFixed(2);\n  \n  currentAnswers = [divisionResult, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  // Update narrative text.\n  narrativeText.setText(\n    `Inside the vault, a safe awaits.\\n\\n` +\n    `The safe displays an IEEE754 32-bit binary string:\\n  ${ieee754Str}\\n\\n` +\n    `Decode this to reveal a positive number (${ieee754Value}).\\n` +\n    `Now, divide the door lock number (${lock1Number}) by this number.\\n` +\n    `Provide the result (rounded to two decimals) to open the safe.`\n  );\n  \n  // Display answer options.\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let opt = scene.add.text(400, 250 + i * 60, `${i + 1}: ${currentAnswers[i]}`, {\n      font: '22px Arial',\n      fill: '#3e2723'\n    }).setOrigin(0.5);\n    optionTexts.push(opt);\n  }\n}\n\n/* --------------------------\n   Input Handler: handleKey\n   --------------------------\n   Listens for number key presses (1, 2, 3) to select an answer.\n   If correct, advances the game; if incorrect, provides feedback.\n*/\nfunction handleKey(event) {\n  let key = event.key;\n  let index = parseInt(key) - 1;\n  if (isNaN(index) || index < 0 || index >= currentAnswers.length) return;\n  \n  // Check answer based on the current puzzle stage.\n  if (puzzleStage === 1) {\n    if (currentAnswers[index] === lock1Correct) {\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The door lock clicks open!\\n\\nYou proceed to the vault...\");\n      // Brief delay, then move to Lock 2.\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        setupLock2(game.scene.scenes[0]);\n      }, [], this);\n    } else {\n      narrativeText.setText(\"Incorrect 2's complement!\\nTry again.\");\n    }\n  } else if (puzzleStage === 2) {\n    if (currentAnswers[index] === divisionResult) {\n      score += 20;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The safe unlocks with a satisfying click!\\nCongratulations, you've completed the heist!\");\n      clearOptions();\n    } else {\n      narrativeText.setText(\"Incorrect division result!\\nRecheck your calculation.\");\n    }\n  }\n}\n\n/* --------------------------\n   Utility Functions\n   --------------------------\n*/\n\n/**\n * Clears option text objects from the scene.\n */\nfunction clearOptions() {\n  optionTexts.forEach(opt => opt.destroy());\n  optionTexts = [];\n}\n\n/**\n * Converts a float number to its IEEE754 32-bit binary representation.\n */\nfunction floatToIEEE754(num) {\n  let f32 = new Float32Array(1);\n  f32[0] = num;\n  let u32 = new Uint32Array(f32.buffer);\n  return u32[0].toString(2).padStart(32, '0');\n}\n\n/**\n * Flips one random bit in a binary string.\n */\nfunction alterBit(binaryStr) {\n  const index = Phaser.Math.Between(0, binaryStr.length - 1);\n  const newBit = binaryStr[index] === '0' ? '1' : '0';\n  return binaryStr.substring(0, index) + newBit + binaryStr.substring(index + 1);\n}\n",
      "timestamp": "2025-02-04T12:44:13.479Z",
      "totalPoints": 0
    },
    {
      "id": "4f47db72-8123-4b53-b97f-e1ff0adde04a",
      "name": "IEEE754",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#a7ffeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global state variables\nlet mode = \"exploration\"; // \"exploration\" or \"puzzle\"\nlet puzzleStage = 0;      // 1 = door lock puzzle, 2 = safe puzzle\nlet doorLockSolved = false;\nlet safeSolved = false;\nlet score = 0;\n\n// Exploration objects\nlet player, doorLock, safe, ground;\nlet cursors, interactKey;\n\n// UI texts (common to both modes)\nlet scoreText, narrativeText;\nlet optionTexts = [];\n\n// Puzzle variables for Lock 1 (Door Lock: 2's Complement)\nlet lock1Number;   // random negative integer between -128 and -1\nlet lock1Correct;  // its correct 8-bit 2's complement representation\n\n// Puzzle variables for Lock 2 (Safe Lock: Division Puzzle)\nlet ieee754Str;     // IEEE754 32-bit representation (of a random positive float)\nlet ieee754Value;   // the decoded float value (for display clarity)\nlet divisionResult; // result of lock1Number / ieee754Value (rounded to 2 decimals)\nlet currentAnswers = []; // answer options for the current puzzle\n\nfunction preload() {\n  // Create simple textures using graphics\n  this.graphics = this.add.graphics();\n  \n  // Player texture: a blue square\n  this.graphics.fillStyle(0x2196f3, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('player', 32, 32);\n  this.graphics.clear();\n  \n  // Door lock texture: a brown rectangle\n  this.graphics.fillStyle(0x6d4c41, 1);\n  this.graphics.fillRect(0, 0, 48, 48);\n  this.graphics.generateTexture('doorLock', 48, 48);\n  this.graphics.clear();\n  \n  // Safe texture: a dark gray square\n  this.graphics.fillStyle(0x424242, 1);\n  this.graphics.fillRect(0, 0, 48, 48);\n  this.graphics.generateTexture('safe', 48, 48);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // --- Create the Landscape ---\n  // Create ground as a static physics body.\n  ground = this.physics.add.staticGroup();\n  ground.create(400, 580, 'safe').setScale(16, 0.5).refreshBody(); // Using safe texture as a simple rectangle\n  \n  // Create player sprite\n  player = this.physics.add.sprite(100, 500, 'player');\n  player.setCollideWorldBounds(true);\n  \n  // Enable collisions with ground.\n  this.physics.add.collider(player, ground);\n  \n  // Create door lock object (if not solved yet)\n  doorLock = this.physics.add.staticSprite(150, 520, 'doorLock');\n  \n  // Create safe object (will be available after door lock is solved)\n  safe = this.physics.add.staticSprite(650, 520, 'safe');\n  safe.visible = false; // hide safe until door lock is solved\n  \n  // Create UI texts.\n  scoreText = this.add.text(16, 16, 'Score: 0', { font: '20px Arial', fill: '#000' });\n  narrativeText = this.add.text(400, 50, 'Explore the world.\\nUse arrow keys to move.\\nPress E to interact with nearby objects.', \n    { font: '20px Arial', fill: '#000', align: 'center' }).setOrigin(0.5);\n  \n  // Set up input keys.\n  cursors = this.input.keyboard.createCursorKeys();\n  interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);\n  // Also listen for number keys for puzzle answers.\n  this.input.keyboard.on('keydown', handleKey, this);\n}\n\nfunction update() {\n  if (mode === \"exploration\") {\n    // --- Player Movement ---\n    player.setVelocityX(0);\n    if (cursors.left.isDown) {\n      player.setVelocityX(-160);\n    } else if (cursors.right.isDown) {\n      player.setVelocityX(160);\n    }\n    if (cursors.up.isDown && player.body.touching.down) {\n      player.setVelocityY(-330);\n    }\n    \n    // --- Interaction Check ---\n    // Check if player is near door lock (and door lock not yet solved).\n    if (!doorLockSolved && Phaser.Math.Distance.Between(player.x, player.y, doorLock.x, doorLock.y) < 70) {\n      narrativeText.setText('Press E to interact with the Door Lock.');\n      if (Phaser.Input.Keyboard.JustDown(interactKey)) {\n        startPuzzle(1, this);\n      }\n    }\n    // Check if door lock is solved and safe is available.\n    else if (doorLockSolved && !safeSolved && Phaser.Math.Distance.Between(player.x, player.y, safe.x, safe.y) < 70) {\n      narrativeText.setText('Press E to interact with the Safe.');\n      if (Phaser.Input.Keyboard.JustDown(interactKey)) {\n        startPuzzle(2, this);\n      }\n    }\n    else {\n      narrativeText.setText('Explore the world.\\nUse arrow keys to move.\\nPress E to interact with nearby objects.');\n    }\n  }\n  // When in puzzle mode, movement is disabled.\n}\n\n/* ---------------------------\n   Puzzle Mode Starter\n--------------------------- */\nfunction startPuzzle(stage, scene) {\n  mode = \"puzzle\";\n  puzzleStage = stage;\n  \n  // Hide exploration objects\n  player.visible = false;\n  doorLock.visible = false;\n  safe.visible = false;\n  \n  // Clear any previous puzzle options.\n  clearOptions();\n  \n  if (stage === 1) {\n    setupLock1(scene);\n  } else if (stage === 2) {\n    setupLock2(scene);\n  }\n}\n\n/* ---------------------------\n   LOCK 1: Door Lock Puzzle\n   ---------------------------\n   Convert a negative decimal (lock1Number) to its 8-bit 2's complement.\n*/\nfunction setupLock1(scene) {\n  // Generate a random negative integer between -128 and -1.\n  lock1Number = Phaser.Math.Between(-128, -1);\n  // Compute its 8-bit 2's complement.\n  let twosValue = 256 + lock1Number;\n  lock1Correct = twosValue.toString(2).padStart(8, '0');\n  \n  // Generate two distractors by flipping a random bit.\n  let distractor1 = alterBit(lock1Correct);\n  let distractor2 = alterBit(lock1Correct);\n  while (distractor1 === lock1Correct) {\n    distractor1 = alterBit(lock1Correct);\n  }\n  while (distractor2 === lock1Correct || distractor2 === distractor1) {\n    distractor2 = alterBit(lock1Correct);\n  }\n  \n  currentAnswers = [lock1Correct, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  narrativeText.setText(\n    `Door Lock Challenge:\\n\\n` +\n    `A panel displays the decimal number:\\n  ${lock1Number}\\n\\n` +\n    `Convert it to its 8-bit 2's complement representation.`\n  );\n  \n  displayOptions(scene);\n}\n\n/* ---------------------------\n   LOCK 2: Safe Lock Puzzle\n   ---------------------------\n   Divide the door lock number (lock1Number) by a positive number decoded from an IEEE754 binary string.\n*/\nfunction setupLock2(scene) {\n  // Generate a random positive float between 1 and 20.\n  let randomFloat = Phaser.Math.FloatBetween(1, 20);\n  randomFloat = parseFloat(randomFloat.toFixed(2));\n  \n  // Convert it to IEEE754 32-bit binary representation.\n  ieee754Str = floatToIEEE754(randomFloat);\n  ieee754Value = randomFloat;\n  \n  // Compute the division: (lock1Number) divided by (randomFloat).\n  divisionResult = (lock1Number / randomFloat).toFixed(2);\n  \n  // Create two distractors by adding/subtracting a small random offset.\n  let offset1 = parseFloat(Phaser.Math.FloatBetween(0.1, 1).toFixed(2));\n  let offset2 = parseFloat(Phaser.Math.FloatBetween(0.1, 1).toFixed(2));\n  let distractor1 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? offset1 : -offset1)).toFixed(2);\n  let distractor2 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? offset2 : -offset2)).toFixed(2);\n  \n  if (distractor1 === divisionResult) distractor1 = (parseFloat(divisionResult) + 0.1).toFixed(2);\n  if (distractor2 === divisionResult || distractor2 === distractor1) distractor2 = (parseFloat(divisionResult) - 0.1).toFixed(2);\n  \n  currentAnswers = [divisionResult, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  narrativeText.setText(\n    `Safe Challenge:\\n\\n` +\n    `The safe displays an IEEE754 32-bit binary string:\\n  ${ieee754Str}\\n\\n` +\n    `This represents the number: ${ieee754Value}\\n` +\n    `Now, divide the door lock number (${lock1Number}) by this number.\\n` +\n    `Provide the result (rounded to two decimals) to open the safe.`\n  );\n  \n  displayOptions(scene);\n}\n\n/* ---------------------------\n   Display Puzzle Options\n--------------------------- */\nfunction displayOptions(scene) {\n  // Create option texts for the currentAnswers array.\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let opt = scene.add.text(400, 250 + i * 60, `${i + 1}: ${currentAnswers[i]}`, {\n      font: '22px Arial',\n      fill: '#3e2723'\n    }).setOrigin(0.5);\n    optionTexts.push(opt);\n  }\n}\n\n/* ---------------------------\n   Input Handler for Puzzle Answers\n--------------------------- */\nfunction handleKey(event) {\n  // Only process number keys when in puzzle mode.\n  if (mode !== \"puzzle\") return;\n  \n  let index = parseInt(event.key) - 1;\n  if (isNaN(index) || index < 0 || index >= currentAnswers.length) return;\n  \n  if (puzzleStage === 1) {\n    // Door lock puzzle\n    if (currentAnswers[index] === lock1Correct) {\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The door lock clicks open!\\nPreparing to return to the world...\");\n      clearOptions();\n      // Delay a moment before returning to exploration mode.\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        doorLockSolved = true;\n        mode = \"exploration\";\n        // Reveal the safe now that door lock is solved.\n        safe.visible = true;\n        player.visible = true;\n        narrativeText.setText('Explore the world.\\nThe door lock is open.');\n      });\n    } else {\n      narrativeText.setText(\"Incorrect 2's complement!\\nTry again.\");\n    }\n  }\n  else if (puzzleStage === 2) {\n    // Safe puzzle\n    if (currentAnswers[index] === divisionResult) {\n      score += 20;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The safe unlocks with a satisfying click!\\nCongratulations, you've completed the heist!\");\n      clearOptions();\n      safeSolved = true;\n      // End the game or return to exploration mode.\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        mode = \"exploration\";\n        player.visible = true;\n        narrativeText.setText('Explore the world.\\nAll locks are open!');\n      });\n    } else {\n      narrativeText.setText(\"Incorrect division result!\\nRecheck your calculation.\");\n    }\n  }\n}\n\n/* ---------------------------\n   Utility Functions\n--------------------------- */\n\n/**\n * Clears the puzzle option texts.\n */\nfunction clearOptions() {\n  optionTexts.forEach(opt => opt.destroy());\n  optionTexts = [];\n}\n\n/**\n * Converts a float to its IEEE754 32-bit binary representation.\n */\nfunction floatToIEEE754(num) {\n  let f32 = new Float32Array(1);\n  f32[0] = num;\n  let u32 = new Uint32Array(f32.buffer);\n  return u32[0].toString(2).padStart(32, '0');\n}\n\n/**\n * Flips one random bit in a binary string.\n */\nfunction alterBit(binaryStr) {\n  const index = Phaser.Math.Between(0, binaryStr.length - 1);\n  const newBit = binaryStr[index] === '0' ? '1' : '0';\n  return binaryStr.substring(0, index) + newBit + binaryStr.substring(index + 1);\n}\n",
      "timestamp": "2025-02-04T12:49:35.008Z",
      "totalPoints": 0
    },
    {
      "id": "f171f374-976e-4039-ae0d-a047709dbd94",
      "name": "IEEE754",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#a7ffeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global state variables\nlet mode = \"exploration\"; // \"exploration\" or \"puzzle\"\nlet puzzleStage = 0;      // 1 = door lock puzzle, 2 = safe puzzle\nlet doorLockSolved = false;\nlet safeSolved = false;\nlet score = 0;\n\n// Exploration objects\nlet player, doorLock, safe, ground;\nlet cursors, interactKey;\n\n// UI texts (common to both modes)\nlet scoreText, narrativeText;\nlet optionTexts = [];\n\n// Puzzle variables for Lock 1 (Door Lock: 2's Complement)\nlet lock1Number;   // random negative integer between -128 and -1\nlet lock1Correct;  // its correct 8-bit 2's complement representation\n\n// Puzzle variables for Lock 2 (Safe Lock: Division Puzzle)\nlet ieee754Str;     // IEEE754 32-bit representation (of a random positive float)\nlet ieee754Value;   // the decoded float value (for display clarity)\nlet divisionResult; // result of lock1Number / ieee754Value (rounded to 2 decimals)\nlet currentAnswers = []; // answer options for the current puzzle\n\nfunction preload() {\n  // Create simple textures using graphics\n  this.graphics = this.add.graphics();\n  \n  // Player texture: a blue square\n  this.graphics.fillStyle(0x2196f3, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('player', 32, 32);\n  this.graphics.clear();\n  \n  // Door lock texture: a brown rectangle\n  this.graphics.fillStyle(0x6d4c41, 1);\n  this.graphics.fillRect(0, 0, 48, 48);\n  this.graphics.generateTexture('doorLock', 48, 48);\n  this.graphics.clear();\n  \n  // Safe texture: a dark gray square\n  this.graphics.fillStyle(0x424242, 1);\n  this.graphics.fillRect(0, 0, 48, 48);\n  this.graphics.generateTexture('safe', 48, 48);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // --- Create the Landscape ---\n  // Create ground as a static physics body.\n  ground = this.physics.add.staticGroup();\n  // Here we use the safe texture to create a simple ground rectangle.\n  ground.create(400, 580, 'safe').setScale(16, 0.5).refreshBody();\n  \n  // Create player sprite\n  player = this.physics.add.sprite(100, 500, 'player');\n  player.setCollideWorldBounds(true);\n  \n  // Enable collisions with ground.\n  this.physics.add.collider(player, ground);\n  \n  // Create door lock object (if not solved yet)\n  doorLock = this.physics.add.staticSprite(150, 520, 'doorLock');\n  \n  // Create safe object (will be available after door lock is solved)\n  safe = this.physics.add.staticSprite(650, 520, 'safe');\n  safe.visible = false; // hide safe until door lock is solved\n  \n  // Create UI texts.\n  scoreText = this.add.text(16, 16, 'Score: 0', { font: '20px Arial', fill: '#000' });\n  narrativeText = this.add.text(400, 50, 'Explore the world.\\nUse arrow keys to move.\\nPress E to interact with nearby objects.', \n    { font: '20px Arial', fill: '#000', align: 'center' }).setOrigin(0.5);\n  \n  // Set up input keys.\n  cursors = this.input.keyboard.createCursorKeys();\n  interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);\n  // Also listen for number keys for puzzle answers.\n  this.input.keyboard.on('keydown', handleKey, this);\n}\n\nfunction update() {\n  if (mode === \"exploration\") {\n    // --- Player Movement ---\n    player.setVelocityX(0);\n    if (cursors.left.isDown) {\n      player.setVelocityX(-160);\n    } else if (cursors.right.isDown) {\n      player.setVelocityX(160);\n    }\n    if (cursors.up.isDown && player.body.touching.down) {\n      player.setVelocityY(-330);\n    }\n    \n    // --- Interaction Check ---\n    // Check if player is near door lock (and door lock not yet solved).\n    if (!doorLockSolved && Phaser.Math.Distance.Between(player.x, player.y, doorLock.x, doorLock.y) < 70) {\n      narrativeText.setText('Press E to interact with the Door Lock.');\n      if (Phaser.Input.Keyboard.JustDown(interactKey)) {\n        startPuzzle(1, this);\n      }\n    }\n    // Check if door lock is solved and safe is available.\n    else if (doorLockSolved && !safeSolved && Phaser.Math.Distance.Between(player.x, player.y, safe.x, safe.y) < 70) {\n      narrativeText.setText('Press E to interact with the Safe.');\n      if (Phaser.Input.Keyboard.JustDown(interactKey)) {\n        startPuzzle(2, this);\n      }\n    }\n    else {\n      narrativeText.setText('Explore the world.\\nUse arrow keys to move.\\nPress E to interact with nearby objects.');\n    }\n  }\n  // In puzzle mode, player movement is disabled.\n}\n\n/* ---------------------------\n   Puzzle Mode Starter\n--------------------------- */\nfunction startPuzzle(stage, scene) {\n  mode = \"puzzle\";\n  puzzleStage = stage;\n  \n  // Hide exploration objects.\n  player.visible = false;\n  doorLock.visible = false;\n  safe.visible = false;\n  \n  // Clear any previous puzzle options.\n  clearOptions();\n  \n  if (stage === 1) {\n    setupLock1(scene);\n  } else if (stage === 2) {\n    setupLock2(scene);\n  }\n}\n\n/* ---------------------------\n   LOCK 1: Door Lock Puzzle\n   ---------------------------\n   Convert a negative decimal (lock1Number) to its 8-bit 2's complement.\n   This version uses the explicit invert-and-add-1 method implemented via bitwise operators.\n*/\nfunction setupLock1(scene) {\n  // Generate a random negative integer between -128 and -1.\n  lock1Number = Phaser.Math.Between(-128, -1);\n  // Compute its 8-bit 2's complement using our new bitwise method.\n  lock1Correct = computeTwosComplement(lock1Number);\n  \n  // Generate two distractors by flipping one random bit.\n  let distractor1 = alterBit(lock1Correct);\n  let distractor2 = alterBit(lock1Correct);\n  while (distractor1 === lock1Correct) {\n    distractor1 = alterBit(lock1Correct);\n  }\n  while (distractor2 === lock1Correct || distractor2 === distractor1) {\n    distractor2 = alterBit(lock1Correct);\n  }\n  \n  currentAnswers = [lock1Correct, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  narrativeText.setText(\n    `Door Lock Challenge:\\n\\n` +\n    `A panel displays the decimal number:\\n  ${lock1Number}\\n\\n` +\n    `Convert it to its 8-bit 2's complement representation.`\n  );\n  \n  displayOptions(scene);\n}\n\n/* ---------------------------\n   LOCK 2: Safe Lock Puzzle\n   ---------------------------\n   Divide the door lock number (lock1Number) by a positive number decoded from an IEEE754 binary string.\n*/\nfunction setupLock2(scene) {\n  // Generate a random positive float between 1 and 20.\n  let randomFloat = Phaser.Math.FloatBetween(1, 20);\n  randomFloat = parseFloat(randomFloat.toFixed(2));\n  \n  // Convert it to IEEE754 32-bit binary representation.\n  ieee754Str = floatToIEEE754(randomFloat);\n  ieee754Value = randomFloat;\n  \n  // Compute the division: (lock1Number) divided by (randomFloat).\n  divisionResult = (lock1Number / randomFloat).toFixed(2);\n  \n  // Create two distractors by adding/subtracting a small random offset.\n  let offset1 = parseFloat(Phaser.Math.FloatBetween(0.1, 1).toFixed(2));\n  let offset2 = parseFloat(Phaser.Math.FloatBetween(0.1, 1).toFixed(2));\n  let distractor1 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? offset1 : -offset1)).toFixed(2);\n  let distractor2 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? offset2 : -offset2)).toFixed(2);\n  \n  if (distractor1 === divisionResult) distractor1 = (parseFloat(divisionResult) + 0.1).toFixed(2);\n  if (distractor2 === divisionResult || distractor2 === distractor1) distractor2 = (parseFloat(divisionResult) - 0.1).toFixed(2);\n  \n  currentAnswers = [divisionResult, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  narrativeText.setText(\n    `Safe Challenge:\\n\\n` +\n    `The safe displays an IEEE754 32-bit binary string:\\n  ${ieee754Str}\\n\\n` +\n    `This represents the number: ${ieee754Value}\\n` +\n    `Now, divide the door lock number (${lock1Number}) by this number.\\n` +\n    `Provide the result (rounded to two decimals) to open the safe.`\n  );\n  \n  displayOptions(scene);\n}\n\n/* ---------------------------\n   Display Puzzle Options\n--------------------------- */\nfunction displayOptions(scene) {\n  // Create option texts for the currentAnswers array.\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let opt = scene.add.text(400, 250 + i * 60, `${i + 1}: ${currentAnswers[i]}`, {\n      font: '22px Arial',\n      fill: '#3e2723'\n    }).setOrigin(0.5);\n    optionTexts.push(opt);\n  }\n}\n\n/* ---------------------------\n   Input Handler for Puzzle Answers\n--------------------------- */\nfunction handleKey(event) {\n  // Only process number keys when in puzzle mode.\n  if (mode !== \"puzzle\") return;\n  \n  let index = parseInt(event.key) - 1;\n  if (isNaN(index) || index < 0 || index >= currentAnswers.length) return;\n  \n  if (puzzleStage === 1) {\n    // Door lock puzzle\n    if (currentAnswers[index] === lock1Correct) {\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The door lock clicks open!\\nPreparing to return to the world...\");\n      clearOptions();\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        doorLockSolved = true;\n        mode = \"exploration\";\n        // Reveal the safe now that door lock is solved.\n        safe.visible = true;\n        player.visible = true;\n        narrativeText.setText('Explore the world.\\nThe door lock is open.');\n      });\n    } else {\n      narrativeText.setText(\"Incorrect 2's complement!\\nTry again.\");\n    }\n  }\n  else if (puzzleStage === 2) {\n    // Safe puzzle\n    if (currentAnswers[index] === divisionResult) {\n      score += 20;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The safe unlocks with a satisfying click!\\nCongratulations, you've completed the heist!\");\n      clearOptions();\n      safeSolved = true;\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        mode = \"exploration\";\n        player.visible = true;\n        narrativeText.setText('Explore the world.\\nAll locks are open!');\n      });\n    } else {\n      narrativeText.setText(\"Incorrect division result!\\nRecheck your calculation.\");\n    }\n  }\n}\n\n/* ---------------------------\n   Utility Functions\n--------------------------- */\n\n/**\n * Clears the puzzle option texts.\n */\nfunction clearOptions() {\n  optionTexts.forEach(opt => opt.destroy());\n  optionTexts = [];\n}\n\n/**\n * Converts a float to its IEEE754 32-bit binary representation.\n */\nfunction floatToIEEE754(num) {\n  let f32 = new Float32Array(1);\n  f32[0] = num;\n  let u32 = new Uint32Array(f32.buffer);\n  return u32[0].toString(2).padStart(32, '0');\n}\n\n/**\n * Flips one random bit in a binary string.\n */\nfunction alterBit(binaryStr) {\n  const index = Phaser.Math.Between(0, binaryStr.length - 1);\n  const newBit = binaryStr[index] === '0' ? '1' : '0';\n  return binaryStr.substring(0, index) + newBit + binaryStr.substring(index + 1);\n}\n\n/**\n * Computes the 8-bit two's complement representation of a signed number\n * using the \"invert and add 1\" method with bitwise operators.\n *\n * For n < 0:\n *   Uses ((~Math.abs(n) + 1) & 0xFF) to ensure the result fits in 8 bits.\n *\n * For n >= 0, simply returns the 8-bit binary string.\n */\nfunction computeTwosComplement(n) {\n  if (n >= 0) {\n    return n.toString(2).padStart(8, '0');\n  } else {\n    // Use bitwise operations to compute the 8-bit two's complement.\n    return ((~Math.abs(n) + 1) & 0xFF).toString(2).padStart(8, '0');\n  }\n}\n",
      "timestamp": "2025-02-04T13:24:28.516Z",
      "totalPoints": 0
    },
    {
      "id": "e3a647d6-a71a-41a0-92d6-7169fbe382ce",
      "name": "IEEE754",
      "code": "const config = {\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  backgroundColor: '#a7ffeb',\n  physics: {\n    default: 'arcade',\n    arcade: {\n      gravity: { y: 500 },\n      debug: false\n    }\n  },\n  scene: {\n    preload,\n    create,\n    update\n  }\n};\n\nconst game = new Phaser.Game(config);\n\n// Global state variables\nlet mode = \"exploration\"; // \"exploration\" or \"puzzle\"\nlet puzzleStage = 0;      // 1 = door lock puzzle, 2 = safe puzzle\nlet doorLockSolved = false;\nlet safeSolved = false;\nlet score = 0;\n\n// Exploration objects\nlet player, doorLock, safe, ground;\nlet cursors, interactKey;\n\n// UI texts (common to both modes)\nlet scoreText, narrativeText;\nlet optionTexts = [];\n\n// Puzzle variables for Lock 1 (Door Lock: 2's Complement)\nlet lock1Number;   // random negative integer between -128 and -1\nlet lock1Correct;  // its correct 8-bit 2's complement representation\n\n// Puzzle variables for Lock 2 (Safe Lock: Division Puzzle)\nlet ieee754Str;     // IEEE754 32-bit representation (of a random positive float)\nlet ieee754Value;   // the decoded float value (for display clarity)\nlet divisionResult; // result of lock1Number / ieee754Value (rounded to 2 decimals)\nlet currentAnswers = []; // answer options for the current puzzle\n\nfunction preload() {\n  // Create simple textures using graphics\n  this.graphics = this.add.graphics();\n  \n  // Player texture: a blue square\n  this.graphics.fillStyle(0x2196f3, 1);\n  this.graphics.fillRect(0, 0, 32, 32);\n  this.graphics.generateTexture('player', 32, 32);\n  this.graphics.clear();\n  \n  // Door lock texture: a brown rectangle\n  this.graphics.fillStyle(0x6d4c41, 1);\n  this.graphics.fillRect(0, 0, 48, 48);\n  this.graphics.generateTexture('doorLock', 48, 48);\n  this.graphics.clear();\n  \n  // Safe texture: a dark gray square\n  this.graphics.fillStyle(0x424242, 1);\n  this.graphics.fillRect(0, 0, 48, 48);\n  this.graphics.generateTexture('safe', 48, 48);\n  this.graphics.clear();\n}\n\nfunction create() {\n  // --- Create the Landscape ---\n  // Create ground as a static physics body.\n  ground = this.physics.add.staticGroup();\n  // Here we use the safe texture to create a simple ground rectangle.\n  ground.create(400, 580, 'safe').setScale(16, 0.5).refreshBody();\n  \n  // Create player sprite\n  player = this.physics.add.sprite(100, 500, 'player');\n  player.setCollideWorldBounds(true);\n  \n  // Enable collisions with ground.\n  this.physics.add.collider(player, ground);\n  \n  // Create door lock object (if not solved yet)\n  doorLock = this.physics.add.staticSprite(150, 520, 'doorLock');\n  \n  // Create safe object (will be available after door lock is solved)\n  safe = this.physics.add.staticSprite(650, 520, 'safe');\n  safe.visible = false; // hide safe until door lock is solved\n  \n  // Create UI texts.\n  scoreText = this.add.text(16, 16, 'Score: 0', { font: '20px Arial', fill: '#000' });\n  narrativeText = this.add.text(400, 50, 'Explore the world.\\nUse arrow keys to move.\\nPress E to interact with nearby objects.', \n    { font: '20px Arial', fill: '#000', align: 'center' }).setOrigin(0.5);\n  \n  // Set up input keys.\n  cursors = this.input.keyboard.createCursorKeys();\n  interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);\n  // Also listen for number keys for puzzle answers.\n  this.input.keyboard.on('keydown', handleKey, this);\n}\n\nfunction update() {\n  if (mode === \"exploration\") {\n    // --- Player Movement ---\n    player.setVelocityX(0);\n    if (cursors.left.isDown) {\n      player.setVelocityX(-160);\n    } else if (cursors.right.isDown) {\n      player.setVelocityX(160);\n    }\n    if (cursors.up.isDown && player.body.touching.down) {\n      player.setVelocityY(-330);\n    }\n    \n    // --- Interaction Check ---\n    // Check if player is near door lock (and door lock not yet solved).\n    if (!doorLockSolved && Phaser.Math.Distance.Between(player.x, player.y, doorLock.x, doorLock.y) < 70) {\n      narrativeText.setText('Press E to interact with the Door Lock.');\n      if (Phaser.Input.Keyboard.JustDown(interactKey)) {\n        startPuzzle(1, this);\n      }\n    }\n    // Check if door lock is solved and safe is available.\n    else if (doorLockSolved && !safeSolved && Phaser.Math.Distance.Between(player.x, player.y, safe.x, safe.y) < 70) {\n      narrativeText.setText('Press E to interact with the Safe.');\n      if (Phaser.Input.Keyboard.JustDown(interactKey)) {\n        startPuzzle(2, this);\n      }\n    }\n    else {\n      narrativeText.setText('Explore the world.\\nUse arrow keys to move.\\nPress E to interact with nearby objects.');\n    }\n  }\n  // In puzzle mode, player movement is disabled.\n}\n\n/* ---------------------------\n   Puzzle Mode Starter\n--------------------------- */\nfunction startPuzzle(stage, scene) {\n  mode = \"puzzle\";\n  puzzleStage = stage;\n  \n  // Hide exploration objects.\n  player.visible = false;\n  doorLock.visible = false;\n  safe.visible = false;\n  \n  // Clear any previous puzzle options.\n  clearOptions();\n  \n  if (stage === 1) {\n    setupLock1(scene);\n  } else if (stage === 2) {\n    setupLock2(scene);\n  }\n}\n\n/* ---------------------------\n   LOCK 1: Door Lock Puzzle\n   ---------------------------\n   Convert a negative decimal (lock1Number) to its 8-bit 2's complement.\n   This version uses the explicit invert-and-add-1 method implemented via bitwise operators.\n*/\nfunction setupLock1(scene) {\n  // Generate a random negative integer between -128 and -1.\n  lock1Number = Phaser.Math.Between(-128, -1);\n  // Compute its 8-bit 2's complement using our new bitwise method.\n  lock1Correct = computeTwosComplement(lock1Number);\n  \n  // Generate two distractors by flipping one random bit.\n  let distractor1 = alterBit(lock1Correct);\n  let distractor2 = alterBit(lock1Correct);\n  while (distractor1 === lock1Correct) {\n    distractor1 = alterBit(lock1Correct);\n  }\n  while (distractor2 === lock1Correct || distractor2 === distractor1) {\n    distractor2 = alterBit(lock1Correct);\n  }\n  \n  currentAnswers = [lock1Correct, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  narrativeText.setText(\n    `Door Lock Challenge:\\n\\n` +\n    `A panel displays the decimal number:\\n  ${lock1Number}\\n\\n` +\n    `Convert it to its 8-bit 2's complement representation.`\n  );\n  \n  displayOptions(scene);\n}\n\n/* ---------------------------\n   LOCK 2: Safe Lock Puzzle\n   ---------------------------\n   Divide the door lock number (lock1Number) by a positive number decoded from an IEEE754 binary string.\n*/\nfunction setupLock2(scene) {\n  // Generate a random positive float between 1 and 20.\n  let randomFloat = Phaser.Math.FloatBetween(1, 20);\n  randomFloat = parseFloat(randomFloat.toFixed(2));\n  \n  // Convert it to IEEE754 32-bit binary representation.\n  ieee754Str = floatToIEEE754(randomFloat);\n  ieee754Value = randomFloat;\n  \n  // Compute the division: (lock1Number) divided by (randomFloat).\n  divisionResult = (lock1Number / randomFloat).toFixed(2);\n  \n  // Create two distractors by adding/subtracting a small random offset.\n  let offset1 = parseFloat(Phaser.Math.FloatBetween(0.1, 1).toFixed(2));\n  let offset2 = parseFloat(Phaser.Math.FloatBetween(0.1, 1).toFixed(2));\n  let distractor1 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? offset1 : -offset1)).toFixed(2);\n  let distractor2 = (parseFloat(divisionResult) + (Math.random() < 0.5 ? offset2 : -offset2)).toFixed(2);\n  \n  if (distractor1 === divisionResult) distractor1 = (parseFloat(divisionResult) + 0.1).toFixed(2);\n  if (distractor2 === divisionResult || distractor2 === distractor1) distractor2 = (parseFloat(divisionResult) - 0.1).toFixed(2);\n  \n  currentAnswers = [divisionResult, distractor1, distractor2];\n  Phaser.Utils.Array.Shuffle(currentAnswers);\n  \n  narrativeText.setText(\n    `Safe Challenge:\\n\\n` +\n    `The safe displays an IEEE754 32-bit binary string:\\n  ${ieee754Str}\\n\\n` +\n    `This represents the number: ${ieee754Value}\\n` +\n    `Now, divide the door lock number (${lock1Number}) by this number.\\n` +\n    `Provide the result (rounded to two decimals) to open the safe.`\n  );\n  \n  displayOptions(scene);\n}\n\n/* ---------------------------\n   Display Puzzle Options\n--------------------------- */\nfunction displayOptions(scene) {\n  // Create option texts for the currentAnswers array.\n  for (let i = 0; i < currentAnswers.length; i++) {\n    let opt = scene.add.text(400, 250 + i * 60, `${i + 1}: ${currentAnswers[i]}`, {\n      font: '22px Arial',\n      fill: '#3e2723'\n    }).setOrigin(0.5);\n    optionTexts.push(opt);\n  }\n}\n\n/* ---------------------------\n   Input Handler for Puzzle Answers\n--------------------------- */\nfunction handleKey(event) {\n  // Only process number keys when in puzzle mode.\n  if (mode !== \"puzzle\") return;\n  \n  let index = parseInt(event.key) - 1;\n  if (isNaN(index) || index < 0 || index >= currentAnswers.length) return;\n  \n  if (puzzleStage === 1) {\n    // Door lock puzzle\n    if (currentAnswers[index] === lock1Correct) {\n      score += 10;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The door lock clicks open!\\nPreparing to return to the world...\");\n      clearOptions();\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        doorLockSolved = true;\n        mode = \"exploration\";\n        // Reveal the safe now that door lock is solved.\n        safe.visible = true;\n        player.visible = true;\n        narrativeText.setText('Explore the world.\\nThe door lock is open.');\n      });\n    } else {\n      narrativeText.setText(\"Incorrect 2's complement!\\nTry again.\");\n    }\n  }\n  else if (puzzleStage === 2) {\n    // Safe puzzle\n    if (currentAnswers[index] === divisionResult) {\n      score += 20;\n      scoreText.setText('Score: ' + score);\n      narrativeText.setText(\"The safe unlocks with a satisfying click!\\nCongratulations, you've completed the heist!\");\n      clearOptions();\n      safeSolved = true;\n      game.scene.scenes[0].time.delayedCall(1500, () => {\n        mode = \"exploration\";\n        player.visible = true;\n        narrativeText.setText('Explore the world.\\nAll locks are open!');\n      });\n    } else {\n      narrativeText.setText(\"Incorrect division result!\\nRecheck your calculation.\");\n    }\n  }\n}\n\n/* ---------------------------\n   Utility Functions\n--------------------------- */\n\n/**\n * Clears the puzzle option texts.\n */\nfunction clearOptions() {\n  optionTexts.forEach(opt => opt.destroy());\n  optionTexts = [];\n}\n\n/**\n * Converts a float to its IEEE754 32-bit binary representation.\n */\nfunction floatToIEEE754(num) {\n  let f32 = new Float32Array(1);\n  f32[0] = num;\n  let u32 = new Uint32Array(f32.buffer);\n  return u32[0].toString(2).padStart(32, '0');\n}\n\n/**\n * Flips one random bit in a binary string.\n */\nfunction alterBit(binaryStr) {\n  const index = Phaser.Math.Between(0, binaryStr.length - 1);\n  const newBit = binaryStr[index] === '0' ? '1' : '0';\n  return binaryStr.substring(0, index) + newBit + binaryStr.substring(index + 1);\n}\n\n/**\n * Computes the 8-bit two's complement representation of a signed number\n * using the \"invert and add 1\" method with bitwise operators.\n *\n * For n < 0:\n *   Uses ((~Math.abs(n) + 1) & 0xFF) to ensure the result fits in 8 bits.\n *\n * For n >= 0, simply returns the 8-bit binary string.\n */\nfunction computeTwosComplement(n) {\n  if (n >= 0) {\n    return n.toString(2).padStart(8, '0');\n  } else {\n    // Use bitwise operations to compute the 8-bit two's complement.\n    return ((~Math.abs(n) + 1) & 0xFF).toString(2).padStart(8, '0');\n  }\n}\n",
      "timestamp": "2025-02-04T13:47:52.509Z",
      "totalPoints": 0
    },
    {
      "id": "579e25e0-cb2a-47d7-9be5-ec13976d6d2d",
      "name": "Game",
      "code": "const config = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 600,\n    parent: 'phaser-game', // Make sure an element with id=\"phaser-game\" exists in your HTML\n    scene: {\n        preload: preload,\n        create: create,\n        update: update\n    }\n};\n\nconst game = new Phaser.Game(config);\n\n// Array of question objects for scalability\nconst questions = [\n    {\n        questionText: 'What is the capital of France?',\n        answers: ['A) Berlin', 'B) Paris', 'C) London'],\n        correct: 1 // using the index of the correct answer (0-based)\n    },\n    {\n        questionText: 'Which planet is known as the Red Planet?',\n        answers: ['A) Earth', 'B) Jupiter', 'C) Mars'],\n        correct: 2\n    },\n    {\n        questionText: 'What is the largest ocean on Earth?',\n        answers: ['A) Atlantic', 'B) Indian', 'C) Pacific'],\n        correct: 2\n    },\n    {\n        questionText: 'Who wrote \"Hamlet\"?',\n        answers: ['A) Charles Dickens', 'B) William Shakespeare', 'C) Mark Twain'],\n        correct: 1\n    },\n    {\n        questionText: 'What is the chemical symbol for Gold?',\n        answers: ['A) Au', 'B) Ag', 'C) Gd'],\n        correct: 0\n    },\n    {\n        questionText: 'In which year did the Titanic sink?',\n        answers: ['A) 1912', 'B) 1920', 'C) 1905'],\n        correct: 0\n    },\n    {\n        questionText: 'What is the tallest mountain in the world?',\n        answers: ['A) K2', 'B) Kangchenjunga', 'C) Mount Everest'],\n        correct: 2\n    },\n    {\n        questionText: 'Which element has the atomic number 1?',\n        answers: ['A) Oxygen', 'B) Hydrogen', 'C) Carbon'],\n        correct: 1\n    },\n    {\n        questionText: 'Who painted the Mona Lisa?',\n        answers: ['A) Vincent Van Gogh', 'B) Pablo Picasso', 'C) Leonardo da Vinci'],\n        correct: 2\n    },\n    {\n        questionText: 'What is the currency of Japan?',\n        answers: ['A) Yen', 'B) Dollar', 'C) Euro'],\n        correct: 0\n    }\n];\n\nlet currentQuestionIndex = 0;\nlet questionText;\nlet answerTexts = []; // array to hold the answer text objects\n\nfunction preload() {\n    console.log('Preload started');\n    this.load.image('background', 'https://picsum.photos/800/600');\n}\n\nfunction create() {\n    console.log('Create called');\n    // Add the background image and set its origin to the top-left corner\n    this.add.image(0, 0, 'background').setOrigin(0, 0);\n    \n    // Render the first question\n    renderQuestion.call(this);\n}\n\nfunction update() {\n    // Currently, no continuous updates are needed.\n}\n\n// Function to render a question\nfunction renderQuestion() {\n    // Clear any previous question (if it exists)\n    if (questionText) {\n        questionText.destroy();\n    }\n    answerTexts.forEach(function(textObj) {\n        textObj.destroy();\n    });\n    answerTexts = [];\n\n    // Get the current question object\n    const currentQuestion = questions[currentQuestionIndex];\n\n    // Add the question text at the top center of the screen\n    questionText = this.add.text(400, 150, currentQuestion.questionText, { fontSize: '24px', fill: '#ffffff' });\n    questionText.setOrigin(0.5);\n\n    // Dynamically render answer options\n    const startX = 200;\n    const gapX = 200;\n    const posY = 400;\n\n    currentQuestion.answers.forEach((answer, index) => {\n        let answerText = this.add.text(startX + index * gapX, posY, answer, { fontSize: '18px', fill: '#ffffff' });\n        answerText.setOrigin(0.5);\n        answerText.setInteractive(); // Enable input for this text\n        // Add an event handler for when an answer is clicked\n        answerText.on('pointerdown', () => {\n            checkAnswer.call(this, index);\n        });\n        answerTexts.push(answerText);\n    });\n}\n\n// Function to check the player's answer\nfunction checkAnswer(selectedIndex) {\n    const currentQuestion = questions[currentQuestionIndex];\n    if (selectedIndex === currentQuestion.correct) {\n        questionText.setText('Correct! Next question...');\n    } else {\n        questionText.setText('Incorrect. Next question...');\n    }\n    \n    // Delay moving to the next question so the player can read the feedback\n    this.time.delayedCall(2000, nextQuestion, [], this);\n}\n\n// Function to load the next question or restart the quiz\nfunction nextQuestion() {\n    currentQuestionIndex++;\n    if (currentQuestionIndex >= questions.length) {\n        // Optionally, you can restart the quiz or display a completion message\n        questionText.setText('Quiz complete!');\n        answerTexts.forEach(function(textObj) {\n            textObj.destroy();\n        });\n    } else {\n        renderQuestion.call(this);\n    }\n}\n",
      "timestamp": "2025-02-05T15:02:31.602Z",
      "totalPoints": 0
    },
    {
      "id": "b2c0b867-0ad3-4aa9-b741-96348e2a28e7",
      "name": "Deutsch Quiz",
      "code": "var config = {\n    type: Phaser.CANVAS,\n    width: 800,\n    height: 600,\n    backgroundColor: '#FFC0CB', // Rosa Hintergrund\n    physics: {\n        default: 'arcade',\n        arcade: {\n            gravity: { y: 300 },\n            debug: false\n        }\n    },\n    scene: {\n        preload: preload,\n        create: create,\n        update: update\n    }\n};\n\nvar game = new Phaser.Game(config);\n\nvar player;\nvar cursors;\nvar platforms;\nvar enemyGroup;\nvar points = 0;\nvar pointsText;\nvar mathQuestions;\nvar currentMathQuestion;\nvar winAchieved = false; // Damit der Gewinn nur einmal ausgelöst wird\n\nfunction preload() {\n    // Falls du eigene Bilder laden möchtest, kannst du das hier tun.\n    // Erzeuge eine einfache Partikel-Textur für Konfetti:\n    var graphics = this.make.graphics({ x: 0, y: 0, add: false });\n    graphics.fillStyle(0xffffff, 1);\n    graphics.fillRect(0, 0, 4, 4);\n    graphics.generateTexture('confetti', 4, 4);\n}\n\nfunction create() {\n    // Plattformen erstellen\n    platforms = this.physics.add.staticGroup();\n    // Boden\n    platforms.create(400, 580, null).setDisplaySize(800, 40).setOrigin(0.5).refreshBody();\n    // Weitere Plattformen\n    platforms.create(600, 400, null).setDisplaySize(200, 20).refreshBody();\n    platforms.create(50, 250, null).setDisplaySize(200, 20).refreshBody();\n    platforms.create(750, 220, null).setDisplaySize(200, 20).refreshBody();\n\n    // Punkteanzeige\n    pointsText = this.add.text(20, 20, 'Punkte: ' + points, { fontSize: '24px', fill: '#000' });\n\n    // Spieler erstellen (als einfacher farbiger Kasten)\n    player = this.physics.add.sprite(100, 450, null);\n    player.displayWidth = 40;\n    player.displayHeight = 60;\n    player.setTint(0x0000ff); // Blauer Spieler\n    player.setBounce(0.2);\n    player.setCollideWorldBounds(true);\n    this.physics.add.collider(player, platforms);\n\n    // Steuerung per Cursor-Tasten\n    cursors = this.input.keyboard.createCursorKeys();\n\n    // Gegner erstellen\n    enemyGroup = this.physics.add.group();\n    // Beispiel: Erstelle zwei Gegner als rote Rechtecke\n    var enemy1 = enemyGroup.create(400, 100, null);\n    enemy1.displayWidth = 40;\n    enemy1.displayHeight = 40;\n    enemy1.setTint(0xff0000); // Roter Gegner\n    enemy1.setCollideWorldBounds(true);\n    enemy1.setBounce(1);\n    enemy1.setVelocityX(100);\n\n    var enemy2 = enemyGroup.create(700, 50, null);\n    enemy2.displayWidth = 40;\n    enemy2.displayHeight = 40;\n    enemy2.setTint(0xff0000);\n    enemy2.setCollideWorldBounds(true);\n    enemy2.setBounce(1);\n    enemy2.setVelocityX(-100);\n\n    // Gegner sollen mit den Plattformen kollidieren\n    this.physics.add.collider(enemyGroup, platforms);\n\n    // Überprüfung, wenn der Spieler von einem Gegner berührt wird\n    this.physics.add.overlap(player, enemyGroup, onPlayerKilled, null, this);\n\n    // Definiere eine Reihe von Matheaufgaben\n    mathQuestions = [\n        { question: 'Was ist 7 * 6?', correctAnswer: '42', options: ['36', '42', '48', '40'] },\n        { question: 'Was ist 12 + 15?', correctAnswer: '27', options: ['25', '27', '30', '32'] },\n        { question: 'Was ist 9 - 3?', correctAnswer: '6', options: ['3', '6', '9', '12'] },\n        { question: 'Was ist 8 / 2?', correctAnswer: '4', options: ['2', '3', '4', '5'] }\n    ];\n}\n\nfunction update() {\n    // Spielersteuerung\n    if (cursors.left.isDown) {\n        player.setVelocityX(-160);\n    } else if (cursors.right.isDown) {\n        player.setVelocityX(160);\n    } else {\n        player.setVelocityX(0);\n    }\n\n    if (cursors.up.isDown && player.body.touching.down) {\n        player.setVelocityY(-330);\n    }\n\n    // Gewinnbedingung: Wenn der Spieler ganz oben ist (z. B. y < 50) und noch nicht gewonnen hat\n    if (player.y < 50 && !winAchieved) {\n        winGame.call(this);\n    }\n}\n\nfunction onPlayerKilled(player, enemy) {\n    // Gegner \"töten\" den Spieler: Spiel pausieren und Matheaufgabe anzeigen\n    this.physics.pause();\n    player.setTint(0xff0000); // Spieler wird rot, um den \"Tod\" anzuzeigen\n\n    // Zeige eine zufällige Matheaufgabe\n    showMathQuestion.call(this);\n}\n\nfunction showMathQuestion() {\n    // Wähle zufällig eine Matheaufgabe aus\n    currentMathQuestion = Phaser.Utils.Array.GetRandom(mathQuestions);\n\n    // Erstelle einen halbtransparenten Hintergrund für die Matheaufgabe\n    var overlay = this.add.rectangle(400, 300, 800, 600, 0x000000, 0.5);\n\n    // Zeige die Mathefrage\n    var mathQuestionText = this.add.text(250, 200, currentMathQuestion.question, { fontSize: '32px', fill: '#fff' });\n\n    // Erstelle Antwortoptionen als interaktive Texte\n    var optionTexts = [];\n    for (let i = 0; i < currentMathQuestion.options.length; i++) {\n        let answer = currentMathQuestion.options[i];\n        let optText = this.add.text(300, 260 + i * 40, (i + 1) + ') ' + answer, { fontSize: '28px', fill: '#fff' });\n        optText.setInteractive({ useHandCursor: true });\n        optText.on('pointerdown', () => {\n            if (answer === currentMathQuestion.correctAnswer) {\n                // Richtige Antwort: 10 Punkte hinzufügen\n                points += 10;\n                pointsText.setText('Punkte: ' + points);\n                // Entferne die Matheaufgabe-Elemente und starte das Spiel neu\n                overlay.destroy();\n                mathQuestionText.destroy();\n                optionTexts.forEach(text => text.destroy());\n                restartGame.call(this);\n            } else {\n                // Falsche Antwort: Spieler behält den \"Tod\"-Status\n                mathQuestionText.setText('Falsch! Versuche es noch einmal: ' + currentMathQuestion.question);\n            }\n        });\n        optionTexts.push(optText);\n    }\n}\n\nfunction restartGame() {\n    // Entferne alle Gegner (optional) und setze den Spieler zurück\n    enemyGroup.clear(true, true);\n\n    // Spieler zurücksetzen\n    player.clearTint();\n    player.x = 100;\n    player.y = 450;\n\n    // Physik fortsetzen\n    this.physics.resume();\n\n    // Gegner neu spawnen\n    var enemy1 = enemyGroup.create(400, 100, null);\n    enemy1.displayWidth = 40;\n    enemy1.displayHeight = 40;\n    enemy1.setTint(0xff0000);\n    enemy1.setCollideWorldBounds(true);\n    enemy1.setBounce(1);\n    enemy1.setVelocityX(100);\n\n    var enemy2 = enemyGroup.create(700, 50, null);\n    enemy2.displayWidth = 40;\n    enemy2.displayHeight = 40;\n    enemy2.setTint(0xff0000);\n    enemy2.setCollideWorldBounds(true);\n    enemy2.setBounce(1);\n    enemy2.setVelocityX(-100);\n\n    this.physics.add.collider(enemyGroup, platforms);\n}\n\nfunction winGame() {\n    winAchieved = true;\n    // Punkte für den Gewinn\n    points += 50;\n    pointsText.setText('Punkte: ' + points);\n\n    // Erstelle Konfetti-Partikel\n    var particles = this.add.particles('confetti');\n    var emitter = particles.createEmitter({\n        x: { min: 0, max: 800 },\n        y: 0,\n        angle: { min: 240, max: 300 },\n        speed: { min: 100, max: 300 },\n        gravityY: 300,\n        lifespan: 4000,\n        quantity: 10,\n        scale: { start: 1, end: 0 },\n        blendMode: 'ADD'\n    });\n\n    // Optionale Nachricht anzeigen\n    this.add.text(200, 300, 'Gewonnen!', { fontSize: '48px', fill: '#000' });\n}\n",
      "timestamp": "2025-02-05T18:05:14.597Z",
      "totalPoints": 0
    }
  ]
}